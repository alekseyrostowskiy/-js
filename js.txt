Прямых констант в js  не бывает
infinity и NaN относятся к числовому типу данных
Null- тип данных(простой, но в typeof(null) выдёт object- это общепризнанная ошибка). Когда чего-то просто не существует. 
Undefined. Что-то существует, но не имеет никакого значения	
Объекты- комплексный тип данных
Массив- частный случай объекта. Это объект, у которого ключ- номер по порядку. 


const arrObj = {
  0: "a",
  1: "b",
  name: "c",
};
console.log(arrObj.1);  /* ошибка */
console.log(arrObj[1]); /* получится, поэтому квадратные скобки будут надёжнее*/
console.log(arrObj["name"]); /* без кавычек- ошибка */ если без кавычек, то js думает, что вы обращаетесь к какой-то переменной(а у нас свойство(ключ), а не переменная)
При присваивани тоже самое : arrObj['b'] = 1234 /без кавычек- ошибка

Общение с пользователем: команды: 1. Alert   2.Confirm("  текст  ")   3.Prompt(" текст  ", " значение по умолчнию ")   Они сществуют только внутри браузера

Вся информация, которая приходит от пользователя, будет в виде СТРОК

Унарный плюс- плюс, который использует только один аргумент


Работа с git: ситуация, когда в удал. репозиторий "новее", чем на локальном компьютере: хочешь закомитить измененные файлы и 
выдаёт ошибку---> нужно ввести команду git pull--> произойдёт merge(слияние) репозиториев( далее там нужно ввести :wq!)

Сетевые протоколы:
есть HTTPS, а есть SSH : 
SSH- Secure Shell сетевой протокол для удалённого управления операционными системами и передачей файлов. Он шифрует траффик и делает подключения безопасными
Для создания безопасного соединения используются ключи. Ключи хранятся на локальном компьютере(в специальном файле) и на гитхабе(в нашем случае). При передаче данных авторизация 
в аккаунт гитхаба идёт не через логин и пароль, а через сравнение ключей( если совпадают, то передача разрешается)


Работа с объектами и массивами:
- Array.isArray(массив) - проверка, является ли сущность массивом
- перебор массива:
////
const personalPlanPeter = {
  name: "Peter",
  age: "29",
  skills: {
    languages: ["ru", "eng"],
    programmingLangs: {
      js: "20%",
      php: "10%",
    },
    exp: "1 month",
  },
};

 for (item of personalPlanPeter.skills.languages) {
      str += `${item.toUpperCase()} `;
////

- Метод «arr.forEach(callback[, thisArg])» используется для перебора массива. Он для каждого элемента массива вызывает функцию callback 
(минусс метода в том,что тут нельзя использовать операторы break и continue):
////

    arr.forEach(member => {
        str += `${member} `
    });
////
- метод Object.keys(объект) - возвращает массив, содержащий свойства объекта.
- метод Object.values(объект) - возвращает массив, содержащий значения свойств объекта

- Поверхностная копия объектов происходит, когда мы копируем объект, который содержит в себе другой объект(этот объект будет ссылаться на старый объект)
////
mainObj = {
	a: 1,
	b: 2,
	c: {		   // вот тут будет поверхностная копия
		d: 3,    
		e: 4,
	   },
	};
let objCopy = {};
for( let key in mainObj){
	objCopy[key] = mainObj[key]
   };

- Соединение нескольких объектов: Object.assign(имена объектов)---> можно исп. этот приём для копирования объекта: Object.assign({}, arr): скопировали объект arr
  Чтобы не менять оригинал, а только копию делаем следующее:
////
const restorantData = {
    menu: [
        {
            name: 'Salad Caesar',
            price: '14$'
        },
        {
            name: 'Pizza Diavola',
            price: '9$'
        },
        {
            name: 'Beefsteak',
            price: '17$'
        },
        {
            name: 'Napoleon',
            price: '7$'
        }
    ],
    waitors: [
        {name: 'Alice', age: 22}, {name: 'John', age: 24}
    ],
    averageLunchPrice: '20$',
    openNow: true
};

function transferWaitors(data) {
    const copy = Object.assign({}, data);

    // Нам просто нужно менять весь массив данных,
    // а не лезть напрямую менять каждого из сотрудников
    // Так как это верхний уровень объекта, то значение 
    // будет меняться только у копии
    copy.waitors = [{name: 'Mike', age: 32}];
    return copy;
}

transferWaitors(restorantData);
////

- Копирование старого массива: const newArr = oldArr.slice();
- оператор разворота(разворачивает структуру и превращает её в набор каких-то данных)- spread-оператор:
////
const video = ['a', 'b', 'c'],
	audio = ['d', 'e', 'f'],
	internet= [...video, ...audio, 'g', 'h'];
////
Аналогично работает и с объектами

ООП:
- ООП- это наука о том, как правильно делать архитектуру
- JS- объектно-ориентированный язык
- JS- прототипно ориентированный язык(частный случай ООП)
- в ОЫ все строится на прототипах 
- Объект- сущность с набором свойств и методов
- при работе например со строками(примитивный тип данных) мы сначала создаём строку(typeof(str) выдаст string), а при работе с ним(при вызове метода) JS времнно
  превращает его в объект
- прототипно-ориентированное наследование: например у нас есть машины : она с разными марками, диаметром колёс и т.д., но
  прототипом для них будет то, что они все являются легковыми . Также и с массивами: они могут быть разными, но операции над массивами выполняются одни и те же.
  Когда мы создаём новый массив, мы создаём экземпляр прототипа массива
- Каждый(вроде как) объект имеет свой прототип, который в конечном счёте ссылается на Object, а тот в свою очередь на null. Благодаря прототипам объект как бы имеет свойств прототипа
  (если мы их захотим вывести на экран), но при необходимости мы можем обратиться к этим свойствам

- В проектах можно создать большой прототип модального окна, а от этого прототипа можно создать много маленьких окон
- Установка прототипа(в динмаике, то есть если два объекта уже были созданы):
////
Object.setPrototypeOf(alex, soldier);
////
- Установка прототипа сразу при создании объекта:
////
const chad = Object.create(soldier);
////

- рефакторинг кода- переписывание кода под новые условия или новые задачи

ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ:
-Всё, что получаем от пользователя, будет типом данных - строка
- возможность одного типа данных превращаться в другой
- методы:
  #превращение в строку:
   *String(); - редко пользуются этим способом
   *Конкатенация - (5 + '') - при сложении со строкой у нас всё равно получается строка
- пример:
////
      const num = 5;(номер каталога по порядку)
	console.log("https://vk.com/catalog/" + num);
////
  #превращение в число:
   *Number('4'); -пользуются краааайне редко
   *(+'5') - унарный плюс
   *parseInt("15px", 10)

EX.:
////
	let answ = +prompt("Hello, "");
////
  #превращение в логическое значение:
	ложь: 0, '', null, undefined, NaN
	правда: всё остальное

	*EX.:
////
	let switcher = null;
	
	if (switcher) {
		console.log('Working...');	// не сработает
	}
	
	switcher = 1;
	
	if (switcher) {
		console.log('Working...');      // сработает
	}
////
	*Boolean('4');
	*(!!"4444");  // двойное отрицание

ЗАМЫКАНИЕ И ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ:
	-function declaration- явление, когда функция уже существует(её значение undefined) ещё до того, как код начал выполняться построчно
	- в JS у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний(скрытый от нас) объект - лексическое окружение( lexical environment)
	- Это лексическое окружение делится на 2 части:
		*внутреннее - объект, в котором как свойства хранятся все локльные переменные этой функции(local в sources)
		*внешнее - свойства, которые находятся вне функции(script в sources)
	- замыкание- это когда функция пытается найти что-то внутри себя и если она этого не находит, то она обращается к чему-то, что находится более глобально
	- любая переменная - это свойство объекта лексического окружения
	- лексическое окружение- это технический объект. Напрямую мы с ним никогда не будет работать. Его работу контролирует интерпретатор( в нашем случае браузер
	-РАБОТА ФУНКЦИИ:
	1. Функция стартует с того, что она внутри себя создаёт те переменные, которые в ней созданы( let number = 4; //// тут сначала number = undefined )
	2. Вызов и создание внутреннего и внешнего(глоабального) лексического окружения 
	3. Присвоение значений переменным
	4. Работа с переменными
	5. Сначала функция ищет локальные переменные, а затем глобальные( и так до тех пор пока не дойдёт до самой глобальной области видимости)
	после того как функция отработает, её лексическое окружение уничтожается за ненадобностью 
	- Каждый вызов функции- это создание нового лексического окружения(внутреннего и внешнего), со своими специфическими свойствами(после завершения выполнения внутреннее
	  лкесическое окружение уничтожается)
      - Когда мы возвращаем какую-то функцию в переменную, к примеру, внутренняя лексическая область окружения 
	  будет уничтожена, так как она больше не нужна, но наружу мы позвращаем описание этой функции(что происходит внутри)-объвление этой функции и её замыкания(на что она 	   	  будет ссылаться):
	 	*это как рюкзак с переменными, которые были в области видимости в период создания функции (EX.: если у нас есть функция , которая  объявл. переменные, а затем
	  	возвр. функцию, которая использует эту переменные(она всегда будет хранить ссылку на эту глобальную переменную). Дальнейшее использование этой функции(кот. возвр.
  	  	функцию) для присваивания её какой-то переменной и есть то, что описывалось выше)
	- Closure - замыкание(свойство лексического окружения)
	- Механизм, благодаря которому функция знает, что ей брать и помещать в лексическое окружение - скрытое свойство Environment, которое ссылается на лексическое окружение
	  места, где эта функция была создана( именно благодаря этому свойству функция знает, что положить к себе в замыкание
EX.:
////
	function createCounter(){
		let counter = 0;
		
		const myFunction = function() {
			counter = counter + 1;
			return counter;
		}
		return myFunction;
	}

	const increment = createCounter();
	const c1 = increment();
	const c2 = increment();
	const c3 = increment();
	console.log(c1, c2, c3);     //выведет: 1 2 3
////
	- замыкания- это коллекция всех переменных из области видимости во время создания функции(рюкзак функции)
////
	let b = 1;
function createCounter() {
  let counter = 0;

  const myFunction = function () {
    counter = counter + 1;     /* замыкание */
    b = b + 1;                  /* b к замыканиям не относится, но она также изменяется в глобальной области видимости( то есть тут идёт ссылка на глобальную переменную) */
    return counter + b;
  };
  return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();
console.log(c1, c2, c3);
console.log(b);
////


////
let a = [1];
let b = [1];
console.log(a === b);	//выведет false
////
console.log(4 || 3);	// выведет 4(или запинается на лжи)
////
console.log(4 && 3);	//выведет 3(если оба true - выводится последняя цифра)
////

РАБОТА С DOM:
- Объект window представляет собой окно, содержащее DOM документ
- DOM — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов. 
- в JS объектная модель документа представлена методом document(работает только внутри браузера)
////
const btns = document.getElementsByTagName('button');    //образуется псевдомассив(массив без методов)
////
- У метода querySelectorAll() есть свойтсво forEach()
- инлайн-стили имеют самый главный приоритет
- в js при задании инлайн стилей нужно обращаться именно к конкретному элементу: btns[1].style.borderRadius = '100%'
- способ задания сразу нескольких инлайн-стилей:  box.style.cssText = 'background-color: blue; width: 500px';
- для измененя сразу же несколькоих элементов: 
	1)for - используется крайне редко
	2)element.forEach(item =>{
		item.style.backgroundColor = 'blue';
		}
- создание элемента только в js: const div = document.createElement('div');
- создание текстового узла(он появится на страничке): const text = document.createTextNode('Тут был я');
- при работе со стилями, мы не будем работать с инлайн стилями---> будем использовать классы:
	* стилизация элекментов, которые мы создали
		div.classList.add('black');
- любой элемент можно вставить(удалить, заменить) туда, куда мы захотим, но только по отношению к другому элементу:
	*современные методы для работы со странцией:
		>элемент.append(div)- берём элемент div и ставим его в самый конец элемента
		>элемент.prepend(div)- берём элемент div и ставим его в самое начало элемента
		>element.before(div)- div перед element
		>element.after(div)- div после element
		>element.remove()- удаление элемента
		>element.replaceWith(div)- замена элементом div
	*методы, которые устарели, но мы можем встретить их в своём коде:
		>document.body.appendChild(div) - то же самое, что и document.body.append(div);
		>родитель.insertBefore([блок,который вставляем] , [перед каким элементом мы всталяем])
		>родитель.removeChild(удаляемый элемент)
		>wrapper.replaceChild([чем заменяем], [что заменяем])
- добавление текст в html:
	*div.innerHTML = "Hello World!";
		>можно элементы HTML:
			^div.innerHTML = "<h1>Hello World!</h1>";
	*div.textContent = "Hello" - работает только с текстом(нельзя исп. элекменты HTML)
	*div.insertAdjacentHTML('beforebegin - перед элементом; afterbegin - в начало элемента; beforeend - перед концом; afterend - после элемента', '<h2>Hello</h2>')

- queryselector - выводит в консоль html-конструкцию
- querySelectorAll - выводит в консоль NodeList
- Объект NodeList представляет собой коллекцию узлов. Такой объект возвращается, когда используются такие методы как document.querySelectorAll(), document.getElementsByName()  
  или свойство Node.childNodes. Является псевдомассивом.

СОБЫТИЯ И ИХ ОБРАБОТЧИКИ:
- 3 способа назначить обработчики событий:
	1)в HTML прописываем onclick="alert('Click')" в качестве атрибута - почти не используется
	2)Использование свойства(.onclick) DOM-дерева для событий:		- тоже почти не используется(проблема - при повторении событий в коде выполняется второе 	   		событие(первое игнорируется)+ иногда мы хотим удалять обработчики событий после того как взаимодействие произошло, а с таким способом удалить обработчик нельзя
		////
		const btn = document.querySelectorAll("button");
		btn.onclick = function (){ //теперь onclick это не свойство, а метод(благодаря объявлению функции)
			alert("Click");
		}
		////
	3)методы addEventListener и removeEventListener:
		////
		btn.addEventListener('click', () =>{
			alert("Click");
		})      //мы добавляем обработчик событий(слушатель за событиями). Мы говорим, что js будет следить за этим элементом и если произошло событие, которое  					    описывается в скобках первым аргументом(название события),то он запустит обработчик(второй аргумент)
		////
		*при использовании этого метода будут выполняться все обработчики вне зависимости от их количества.
- события в js выполняются в порядке очереди: как только событие поступило, оно добавляется в очередь независимо от других событий
- объект Event(событие) - передаётся как аргумент в коллбэк функцию(название не играет роли, он всегда передаётся первым аргументом)
- Объект Event описывает событие, произошедшее на странице. Одной из причин возникновения событий являются действия пользователя, такие как клики мышкой MouseEvent или ввод с клавиатуры KeyboardEvent. Существует множество различных событий, которые будут иметь разный набор информации о них.
	*удаление обработчика события:
		////
		let i = 0;
		const deleteElement = (e) => {
			console.log(e.target);
			i++;
			if(i == 1){
				btn.removeEventListener('click', deleteElement);	// если условие сработало, то удаляем этот обработчик
			}
		};
		btn.addEventListener('click', deleteElemet);   // !второй аргумент идёт без круглых скобок после названия функции, так как мы просто ссылаемся на эту функцию, 											   которая будет выполняться после клика, а не вызываем эту функцию
		////
- всплытие событий - когда обработка события сначала срабатывает на вложенном элементе, а затем на его родителе(в случае, если мы назначили одно и то же событие на оба
  элемента)
- Отмена стандратного поведения браузера:
	////
	event.preventDefault();
	////
- нельзя назначать события переменным, которые соедржат несколько элементов странички(полученные через querySelectorAll), так как данная переменная - это псевдомассив. а у 
  массива нет такого метода как addEventListener и т.д.---> нужно этот всевдомассив перебрать и назначить каждому обработчики:
	////
	const btns = document.querySelectorAll('button');
	btns.forEach(btn => {
		btn.addeventListener('click', deleteElement)
	});
	////
- 3-ий аргумент метода addeventListener - options(опции): {once: true} - к примеру

НАВИГАЦИЯ ПО DOM:
- document.documentElement - получение тега <html> - самого главного тега (содержимое всей страницы)
- свойство childNodes - узлы, которые является детьми элемента, у которого мы вызвали это свойство - на выходе получается псевдомассив: 
////
console.log(document.body.childNodes);	//NodeList(10) [text, button#btn, text, button, text, button, text, a, text, script]
NodeList(10) [text, button#btn, text, button, text, button, text, a, text, script]
- разница между DOM-элементами и DOM-узлами: всё, что находится в HTML, является узлом , но не всё, что является узлом, будет элементом
- перенос строки например, который никкак не обозначается в вёрстке тоже является DOM-узлом - называется text
- .firstChild, .lastChild- первый и последние узлы родителя
- .nextSibling, .previousSibling
---->все вышеперечисленные свойства были командами, которые отталкивались от родителя ----> далее покажем свойства, которые отталкиваются от всех элементов страницы
- .parentNode - получаем родителя элемента( можно несколько раз продублировать свойство - выйдем уже на родителя родителя)
- дата-атрибуты -атриюуты, на которые очень удобно ориентироваться в js:
	////	
	document.querySelector('[data-current]').
---> все вышеперечисленные свойства выдают нодовые узлы( среди которых может попасться на какой-нибудь текстовый узел(перенос строки)---> чтобы этого не случалось
     есть следующие свойства:
		*firstElementChild
		*.parentElement
		*.nextelementSibling, previousElementSibling
		*к сожалению для childNodes такого аналога нет(((---> его иногда делают вручную:
			иногда мы не можем перебрать псевдоколлекцию при помощи метода forEach(бывает редко, но такие случаи случаются)---> исп. for(   of   )
			////
			for(let node of document.body.childNodes){
				if(node.nodeName == '#text'){
					continue;
				}
				console.log(node);
			}
			////

БАЗА РЕКУРСИИ:
-основные понятия:
	*база рекурсии
	*шаг рекурсии - запуск вложенной функции , но уже с други значением
	*глубина рекурсии - общее количество вложенных вызовов вместе с самым первым
			
ПРИМЕР ПЕРЕБОРА ОБЪЕКТА:
////
- ищем средний прогресс у всех студентов курсов:
let students = {
	js: [{
		name: 'John',
		progress: 100
	}, {
		name: 'Ivan',
		progress: 60
	}],
	
	html: {
		basic: [{
			name: 'Peter',
			progress: 20
		}, {
			name: 'Ann',
			progress: 18
		}],
	
		pro: [{
			name: 'Sam',
			progress: 10
		}]
	}
};

function getTotalProgressByIteration(data){
	let total = 0;
	let students = 0;

	for( let course of Objects.values(data)) {
		if(Array.isArray(course)) {
			students += course.length;

			for(let i = 0; i <course.length; i++){
				total += course[i].progress;
			}
		} else {
			for(let subCourse of Object.values(course)){
				students += subCourse.length;
				
				for(let i = 0; i < subCourse.length; i++){
					total += subCourse[i].progress;
				}
			}
		}
      }
	return total/students;
}
<--- но при таком подходе нам будет нужно постоянно расширять эту функцию пр добавлении в объект новых свойств(проводить доп. проверки), поэтому легче воспользоваться 	рекурсивным методом
---> теперь создадим рекурсивный перебор с задачей, которая находится выше
- в рекурсивном методе мы не используем как в итеративном методе промежуточные переменные, так как в них нет никакой необходимости 
function getTotalProgressByRecursion(data){
	if(Array.isArray(data)) {
			let total = 0;

			for(let i = 0; i <data.length; i++){
				total += data[i].progress;
			}
				
			return [total, data.length]
	} else {
		let total =[0, 0];
		
		for(let subData of Object.values(data)){
			const  = getTotalProgressByRecursion(subData);
			total[0] += subDataArr[0];
			total[1] += subDataArr[1];
		}
		return total;
	}
}

const result = getTotalProgressByRecursion(students)
coonsole.log(result[0]/result[1]);

-Чтобы скрипт всегда работал и не было ошибок(а они могут появиться вследствие того, что скрипт будет выполняться до того как будет загружена DOM-структура(а если они не
 не загружены, то в скрипте querySelector, к примеру, будет брать несуществующий тег)--->: есть 2 способа :
1. событие load - выполнять скрипт, когда будет подгружено абсолютно всё - редко используется, так как есть случаи, когда необходимо ждать определённое количество времени
2. событие DOMContentLoaded:
////
window.addEventListener('DOMContentLoaded', () => {	// скрипт будет теперь выполняться только тогда, когда DOM-структура будет загружена(а всё остальное подгружается 				весь скрипт				         параллельно 
};
- Событие DOMContentLoaded происходит когда весь HTML был полностью загружен и пройден парсером, не дожидаясь окончания загрузки таблиц стилей, изображений и фреймов. Значительно отличающееся от него событие load используется для отслеживания только полностью загруженной страницы. 

СОБЫТИЯ МОБИЛЬНЫХ УСТРОЙСТВ:
- touchstart - обычное касание элемента
- touchmove - касание+движение
- touchend - как только палец оторвался от элемента
- touchenter - ведём пальцем по экрану и наскакиваем на элемент, на которое повешено это событие
- touchleave - палец продолжил скользить за пределами этого элемента
- touchcancel - точка соприкосновения больше не регистрируется на поверхности 
- у объекта event есть свойства:
	*touches - показывает список всех пальцев, которые находятся на экране
	*targetTouches - показывает список всех пальцев, которые взаимодействуют именно с этим элементом
	*changedTouches - список пальцев, которые участвуют в событии

 ASYNC, DEFER, ДИНАМИЧЕСКИЕ СКРИПТЫ:
- defer - атрибут, который сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем выполнить скрипт, когда он загрузится. Скрипты с defer никогда не блокируют страницу. Особенность defer - скрипт будет выполняться только тогда, когда наше DOM-дерево уже готово(исключается момент, когда скрипт будет брать несуществующий тег). Срабатывает до события DOMContentLoaded
При нахождении нескольких подряд идущих подключений скриптов сохраняется последовательность их выполнения(строго по очереди(пока не выполнится первый, второй вплняться не будет)). Для чего использовать именно defer:
	1)Соблюдение порядка выполнения всех подключенных утилит(можно поставить наиболее важные скрипты в начало, а затем менее важные)
	2) Можно подключить js в любом месте html-файла( можно пометсить в head, хотя некоторые системы, такие как googleSpeedTest ругаются на таккое расположение
- async:
	*страница не ждёт асинхронных скриптов(содержимое просто обрабатываетсяи отображается)
	*события DOMContentLoaded и асинхронные скрипты не ждут друг друга
	*скрипт с атрибутом async загружается в фоновом режиме, но как только он загузился, сразу же запускается, никого не ждёт(остальные скрипты не ждут async и async  не 	ждёт остальных скриптов---> последовательность загрузки скриптов не соблюдается--->для чего это: иногда мы будем подгружать сторонние скрипты, которые не особо 	подвязаны как под DOM-структуру или под другую какую-то функциональность, например метрики и счётчики
	*используем async, когда уверены, что скрипт не зависит от DOM-структуры+ должен не зависеть от других скриптов
- динамические скрипты:
////
function loadScript(src){
	const script = document.createElement('script');
	script.src = src;
	script.async = false;	//если не установить значение false, то данный скрипт будет загружаться асинхронно
	document.body.append(script);	//добавление в конец DOM-структуры
}

loadScript("test.js");
loadScript("some.js");	//скрипты будут выполняться строго друг за другом(благодаря false)	
	*используются часто


CLASSLIST И ДЕЛЕГИРОВАНИЕ СОБЫТИЙ:
- методы classList:
	*btns[0].classList.item(номер по порядку) - получаем конкретный номер класса
	*.add('red') - добавление классов( можно перечислять через запятую
	*.remove('red')
	*.toggle('red') - убирает, если есть и ставит, если нет класс
	*.contains('red') - проверяет наличие класса( возвращает булиновое значение)
	*.className - выводит все классы
- суть делегирования - назначения функции для потомков, которые подходят под определенные параметры:
////
wrapper.addEventListener('click', (event) => {
	if (event.target(проверка на существование event.target(у некоторых тегов нет event.target(у них нет событий клика))) && event.classList.contains('blue'){
		console.log('Hello');
}

или 

wrapper.addEventListener('click', (event) => {
	if (event.target && event.target.matches('button.red'){	// matches() - значит, что какой-то элемент совпадает с чем-то
		console.log('Hello');
}
////
- делегирование - один из самых полезных приёмов для работы с DOM-деревом
- при динамическом изменении элементов, делегирование событий на эти элементы также будет срабатывать( если делать обработчик без делегирования, то если потом добавить динамически в скрипт элемент, на него не будет распространяться это событие)---> экономим место в коде


СОЗДАНИЕ ТАБОВ:
////
window.addEventListener("DOMContentLoaded", () => {
  const tabs = document.querySelectorAll(".tabheader__item"),
    tabsContent = document.querySelectorAll(".tabcontent"),
    tabsParent = document.querySelector(".tabheader__items");

  function hideTabContent() {
    tabsContent.forEach((item) => {
      item.style.display = "none";
    });
    tabs.forEach((item) => {
      item.classList.remove("tabheader__item_active");
    });
  }

  function showTabContent(i = 0) {
    tabsContent[i].style.display = "block";
    tabs[i].classList.add("tabheader__item_active");
  }

  hideTabContent();
  showTabContent();

  tabsParent.addEventListener("click", (event) => {
    const target = event.target;
    if (target && target.classList.contains("tabheader__item")) {
      tabs.forEach((item, i) => {
        if (target == item) {
          hideTabContent();
          showTabContent(i);
        }
      });
    }
  });
});

////

СКРИПТЫ И ВРЕМЯ ИХ ВЫПОЛНЕНИЯ:
- const timerId = setTimeout( function(){
	console.log('text');
}, 2000)
	*функция setTimeout() работает и без переменной, но мы определяем её, так как нам нужен идентификатор этого таймера, чтобы в дальнейшем мы могли его останавливать(очищать):
		>clearInterval(timerId)

const btn = document.querySelector('.btn');
let timerId,
	i = 0;

btn.addEventListener('click', ()=>{
	timerId = setInterval(logger, 500); 
});

function logger(){
	if(i == 3){
		clearInterval(timerId);
	}
	console.log('text');
	i++;
}
- вопрос: Чем рекурсивный setTimeout() лучше, чем setInterval? setInterval-у всё равно смколько выполняется функция(если она выполняется 3 секунды, а мы поставили таймеир на 0,5 секунд, то следующее выполнение функции будет сделано после окончания предыдущего выполнения функции сразу же(без ожидания 0,5 с, так как setInterval считает, что эти 0,5с прошли во время выполнения функции)
////
let id = setTimeout(function log(){		// работает точно также как setInteval(но он четко ждёт окончания выполнения функции, затем ждёт поставленный таймер и затем выполняет опять функцию)
	console.log('Hello');
	id = setTimeout(log, 500);			
}, 500);

////
- практика:
////
function myAnimation(){
	const elem = document.querySelector('.box'):
	let pos = 0;
	const id = setInterval(frame, 10)
	function frame() {
		if(pos == 300){
			clearInterval(id);
		} else{
			pos++;
			elem.style.top = pos + "px";
			elem.style.left = pos + "px";
		}
	}
}

btn.addEventListener('click', myAnimation);


СБОРЩИК МУСОРА И УТЕЧКА ПАМЯТИ:
- JS - высокоуровневый ЯП, интерпретируемый ЯП
- Интерпретаторы и компиляторы отвечают за преобразование языка программирования или сценариев (язык высокого уровня) в машинный код.
- Компилятор  —  это компьютерная программа, которая переводит компьютерный код с одного языка программирования на другой. Компилятор берет программу целиком и преобразует ее в исполняемый компьютерный код. Для этого требуется целая программа, так как компьютер понимает только то, что написано двоичным кодом. Задача компилятора  —  преобразовать исполняемую программу в машинный код, который и распознается компьютером. Примерами скомпилированных языков программирования являются C и C++.
Компилятор в основном используется для программ, которые переводят исходный код с языка программирования высокого уровня на язык программирования более низкого уровня.
Компилятор способен выполнять многие или даже все операции: предварительную обработку данных, парсинг, семантический анализ, преобразование входных программ в промежуточное представление, оптимизацию и генерацию кода.
- Интерпретатор  —  это компьютерная программа, которая преобразует каждый программный оператор высокого уровня в машинный код. Сюда входят исходный код, предварительно скомпилированный код и сценарии.
Интерпретатор представляет собой машинную программу, которая непосредственно выполняет набор инструкций без их компиляции. Примерами интерпретируемых языков являются Perl, Python и Matlab.
И компилятор, и интерпретатор выполняют одну и ту же работу  —  преобразовывают язык программирования высокого уровня в машинный код. Однако компилятор преобразовывает исходный материал в машинный код перед запуском программы. Интерпретатор выполняет эту функцию при ее запуске.
Сначала компилятор создает программу. Он анализирует все операторы языка, чтобы проверить, правильны они или нет. Если компилятор найдет какую-нибудь ошибку, он выдаст соответствующее сообщение. Если же он не обнаружит никаких ошибок, то преобразует исходный код в машинный. Компилятор связывает различные кодовые файлы в программы, которые можно запустить (например, формата .exe). После этого запускается программа.
Интерпретатор создает программу. Он не связывает файлы и не генерирует машинный код. Происходит построчное выполнение исходных операторов во время исполнения программы.
- Преимущества и недостатки:
Преимущества компилятора:
Программный код уже переведен в машинный, и, следовательно, требуется меньше времени на его исполнение.
Файлы .exe выполняются быстрее, чем исходный код. Объектные программы сохраняются и могут быть запущены в любое время.
Объектные программы пользователю сложнее изменить, чем исходный код.
Компилятор проверяет исходный код на наличие синтаксических ошибок во время компиляции.
Недостатки компилятора:
Поскольку переводится вся программа, она использует гораздо больше памяти компьютера.
При работе с компилятором невозможно изменить программу, не вернувшись к исходному коду.
Необходимо создавать объектную программу перед окончательным исполняемым файлом. Это может занять много времени.
Исходный код должен быть на 100% верным для создания исполняемого файла.

Преимущества интерпретатора:
Интерпретатор значительно облегчает работу с исходным кодом.
Он переводит по одной инструкции за раз, поэтому использует минимальный объем памяти.
Интерпретатор может связать сообщения об ошибках с выполняемой инструкцией, что может оказаться полезным в процессе отладки.
Недостатки интерпретатора:
Каждый раз, когда программа выполняется, тратится время на интерпретацию, из-за чего затягивается время исполнения.
Интерпретируемые программы могут выполняться только на компьютерах, на которых имеются соответствующие интерпретаторы.


- объект удаляется, как только становится недостижим(ссылка на него перестаёт существовать).Вполне возможен вариант, когда ссылка на объект есть, но она идёт не от корня(от самой глобальной переменной, которая ссылается по дереву вниз вплоть до того объекта, который нам нужен)
- утечка памяти происходит тогда, когда мы не используем объект, а сборщик мусора всё раввно его не удалил, так как объект является достижимым.
- нельзя делать следующее:
	*(без строгого режима)
	////
	function func(){
		smth = "string";	// всё равно, что напишем window.smth = "string" (объект никогда не будет удалён, так как он глобальный)
	}	
	*Использование таймеров
	////
	const someRes = getData();
	const node = document.querySelector('.class');
	
	setInterval(function() {
		if (node) {
			node.innerHTML = someRes;
		}
	}, 1000);
		>Если мы удалим node, то у нас всё равно останется этот объект достижимым( ссылка на него будет в таймере, который работает каждую секунду)---> утечка памяти---> нужно останавливать ненужные нам таймеры!
	*Обработчики событий на несуществующие элементы:
		>элемент страницы удалён,а обработчик нет---> ссылка на элемент остаётся( раньше это приводило к утечке памяти, но в современных браузерах есть механизм автоматического удаления обработчика события, если элемент, на который он повешен, был удалён)
	* Сохранение ссылок через замыкания:
		////
		function outer() {
			const a = [];
			return function inner(){
				a.push('Hello');	// заыкание (утечка памяти)
				console.log('Hello');
			}
		}
		
		const sayHello = outer();
	*Ссылки на DOM-элементы:
		////
		function createElement() {
			const div = document.createElement('div');
			div.id = 'test';
			return div;
		}
		
		const testDiv = createElement();
		document.body.append(testDiv);
		
		function deleteElement(){
			document.body.removeChild(document.getElementById('test'));
		}
		
		deleteElement();	//тут идёт удаление именно в DOM-дереве, а не в самом JS(утечка памяти)--->
	--->исправим эту ситуацию:
		function createElement() {
			const div = document.createElement('div');
			div.id = 'test';
			document.body.append(testDiv);
		}
		
		createElement();	// после срабатывания функции, её переменная div сразу же удаляется(утечки памяти больше не будет)
		
		
		function deleteElement(){
			document.body.removeChild(document.getElementById('test'));
		}
		
		deleteElement();
		
РАБОТА С ДАТАМИ:
- способы создания даты:
	////
	const now = new Date(2020, 5, 1, 20);	// месяца начинаются с 0
	console.log(now);				// 2020-06-01T17:00:00.000Z


	const now = new Date("2020-06-01");
	console.log(now);				// 2020-06-01T00:00:00.000Z

	const now = new Date(0);			// все даты отсчитываются в миллисекундах от 1970 года
	console.log(now);				// 1970-01-01T00:00:00.000Z


- методы:
	*получение компонента даты:
		////
		переменная.getFullYear()
		переменная.getMonth()
		переменная.getDate()
		переменная.getDay()  // номер дня недели(номерация начинается с воскресенья и с 0)
		////
	Все эти методы возвращают значения в соответствии с нашим часовым поясом и иногда может понадобиться другой часовой пояс (UTC (+0 часов)---> переменная.getUTCHours
		////
		переменная.getTimezoneOffset()	// разница в часовых поясах в минутах
		переменная.getTime()	//количество миллисекунд, которое прошло
	*методы установки даты:
		////
		const now = newDate();
		now.setHours(18,[следующие за ним знаачения - минуты, потом секунды])		// если у нас часовой пояс +3 часа, то выдаст время 15:00 в консоли js, так как js не ориентируется на локальные данные компьютера и выдаёт время UTC, а вот в консоли браузера уже покажется наше время 18:00

		const now = newDate("2020-06-01");   то же самое, что и     const now = newDate.parse("2020-06-01");
		

	*измерение промежутков времени:
		////
		let start = new Date();

		for(let i = 0; i < 100000; i++){
			let some = i ** 3;
		}

		let end = new Date();
		alert(`Цикл отработал за ${end - start} миллисекунд`)

ПАРАМЕТРЫ ДОКУМЕНТА, ОКНА И РАБОТА С НИМИ:
- document - объект, который хранитвсю html-структуру
- window - окно, в котором показывается документ
- screen - это весь наш монитор
- картинка со свойтсвами в папке конспекты
- высветить на экран весь текст(если он был с прокруткой):
	////
	btn.addEventListener('click', () => {
		box.style.height = box.scrollHeight + 'px';
	});

- .getBoundingClientRect() - получает все координаты, которые есть у нашей переменной, в виде объекта
-  window.getComputedStyle(переменная) - объект, со всеми окончательными стилями, которые применились к элементу. Можно получить с помощью этого способа стили, но изменять их таким образом нельзя(исп. только дя проверки чего-то)
- в JS нельзя работать с псевдоэлемента(нет доступа к ним), но стили псведоэлементов получить можно: window.getComputedStyle(переменная, псведоэлемент)


- нельзя сделать так: document.scrollTop() (такого свойства не существует) ----> правильно будет: document.documentElement.scrollTop()
- window.scrollBy(0, 400)     то же самое,что и     document.documentElement.scrollBy(0, 400)			// относительно нынещнего положения скролл на 400px
- window.scrollTo(0,300)	//относительно всей страницы.


СОЗДАНИЕ МОДАЛЬНЫХ ОКОН:
////
  const btn = document.querySelectorAll("[data-modal]"),
    modal = document.querySelector(".modal"),
    closeMod = document.querySelector("[data-close]");

  btn.forEach((item) => {
    item.addEventListener("click", () => {
      modal.style.display = "block";
      /* myMod/classList.add('show'); */
      document.body.style.overflow = "hidden";
    });
  });

  function closeModal() {
    modal.style.display = "none";
    document.body.style.overflow = "";
  }
  closeMod.addEventListener("click", closeModal);

  modal.addEventListener("click", (e) => {
    if (e.target.classList.contains("modal")) {		// при нажатии на пустоту окно закрывается
      closeModal();
    }
  });
////
- события клавиатурных клавиш:
	////
  document.addEventListener("keydown", (e) => {
    if (e.code == "Escape" && modal.style.display == "block") {
      closeModal();
    }
  });
	////
- Открытие окна через 5 секунд после открытия сайта,при этом, если пользователь сам открыл модальное окно до того, как прошло 5 секунд, то мы очищаем интервал, чтобы модальное окноне открывалось повторно
function openModal() {
    modal.style.display = "block";
    document.body.style.overflow = "hidden";
    clearInterval(modalTimerId);
  }
const modalTimerId = setTimeout(openModal, 5000);
- 
////
function showModalByScroll() {
    if (
      document.documentElement
        .scrollTop /* можно также воспользоваться свойством window.pageYOffset */ +
        document.documentElement.clientHeight >=
      document.documentElement.scrollHeight
    ) {
      openModal();
    }
    window.removeEventListener("scroll", showModalByScroll);
  }

MUTATIONOBSERVER: НАБЛЮДАТЕЛЬ ЗА ИЗМЕНЕНИЯМ:
- MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.
- работа идёт с результатом изменения( нельзя запретит, например, ввод каких-либо букв)
- это асинхронная операция( отслеживание может выполниться чуть попозже или чуть-чуть раньше, в зависимости от различных условий. Именно поэтому мы получаем массив(набор изменений, которые произошли))
- Сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:
////
let observer = new MutationObserver(callback);
////
Потом прикрепляем его к DOM-узлу:
////
observer.observe(node, config);
////
config – это объект с булевыми параметрами «на какие изменения реагировать»:
childList – изменения в непосредственных детях node,
subtree – во всех потомках node,
attributes – в атрибутах node,
attributeFilter – массив имён атрибутов, чтобы наблюдать только за выбранными.
characterData – наблюдать ли за node.data (текстовое содержимое),

////
// Выбираем целевой элемент
var target = document.getElementById('some-id');

// Конфигурация observer (за какими изменениями наблюдать)
const config = {
    attributes: true,
    childList: true,
    subtree: true
};

// Колбэк-функция при срабатывании мутации
const callback = function(mutationsList, observer) {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            console.log('A child node has been added or removed.');
        } else if (mutation.type === 'attributes') {
            console.log('The ' + mutation.attributeName + ' attribute was modified.');
        }
    }
};

// Создаём экземпляр наблюдателя с указанной функцией колбэка
const observer = new MutationObserver(callback);

// Начинаем наблюдение за настроенными изменениями целевого элемента
observer.observe(target, config);

// Позже можно остановить наблюдение
observer.disconnect();
/////

ФУНКЦИИ-КОНСТРУКТОРЫ:
- функции по своей сути являются объектами и по идее в нее можно записать какие-то методы и свойства
- старый способ задания объекта:
////
const num = new Number(3)
console.log(num)	// [Number:3]	///создали объект

const num = new Function(3)
console.log(num)	// [Function:anonymous]	///создали функцию(объект, свойства которого уже прописаны в этой функции)
////
- нормальный синтаксис:
////
function User(name, id){
	this.name = name;	// свойства, которые будут отображаться точно также как и в объекте
	this.id = id;
	this.human = true;
	this.hello = function() {
		console.log(`Hello ${this.name}`);	// создание метода
	};
}	// теперь мы можем создавать новых пользователей

const ivan = new User('Ivan', 28')	// внутри переменной будет находиться не функция, а объект, потому что функция User стала конструктором, при вызове которого создаётся объект с теми свойствами, с которыми мы 
 					   его записали
////
- такая функция по факту - прототип, от которого мы можем отпочковывать разные объекты( которые будут относиться к 1 категории(как легковые авто)
- с помощью метода prototype можно добавлять новые методы или свойства в конструктор(этот приём используется, когда нет доступа к прототипу или мы не можем его менять, но нужно что-то добавить):
////
User.prototype.exit = function(){
		console.log(`Пользователь ${this.name} ушёл`);
	}
////
- Конструкторы нужны для создания новых однотипных объектов. В практике это могут быть новые пользователи на сайтах, товары в магазинах, ролики на ютубе
- Всё, что мы рассмотрели выше является стандартом ES5(то как на самом деле всё происходит под капотом JS)---> в ES6 появились классы - синтаксический сахар, то есть красивая обёртка функционала, который существует на
  самом деле( их удобнее использовать)

КОНТЕКСТ ВЫЗОВА.THIS:
- это то, что окружает функцию и то, в каких условиях она вызывается
- если мы просто запускаем функцию, то this будет ссылаться на глобальный объект window(это правило верно для обычного режима(без use strict)). с use strict - this будет иметь значение undefined
- если мы используем функцию внутри функции, контект у неё не меняется( либо window, либо undefined). Так работает всегда для всех функций
- контект у методов объекта - это сам объект (но если мы пропишем функцию отдельную внутри самого метода, то контекст вызова данной функции будет такой же, как и во всех функциях)
- для всех функций-конструкторов контекстом вызова будет являться только что созданный объект . То есть this  в конструкторах и классах - это новый экземляр объекта!
- 2 варианта ручного присвоения контекста:
////
function sayName(surname){
	console.log(this);
	console.log(this.name + surname);
}
const user = {
	name: 'John'
}

sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);	// 2 способа , просто разные синтаксисы присвоения аргументов функции
////
3 способ:
- создаёт новую функцию, связанную с определённым контекстом:
////
function count(num){
	return this*num;
}
	
const double = count.bind(2)	// this будет равняться 2 у double всегда
console.log(double(3));		// 3 - это аргумент
////

- Когда у нашего обработчика события функция написана вот так( function(){}), то контекстом вызова(this) будет элемент, с которым произошло событие
- у стрелочной функции нет своего контекста вызова, она всегда будет брать его у своего родителя( то есть как уже писали выше, если бы мы поместили функцию в метод объекта , то this было бы undefined, но в случае
  стрелочной функции this будет ссылаться на контекст вызова его родителя, то есть на метод объекта, а тот в свою очередь будет ссылаться на объект). А при нахождении стрелочной функции в обработчике событий, контекст
  вызова будет либо undefined, либо window

КЛАССЫ ES6:
- по простому классы - это красивая обёртка функций-конструкторов
////
class Rectangle{
	constructor(height, width){   
		this.heught = height;
		this.width = width;
	}
	calcArea(){
		return this.height*this.width;
	}
}
////
- принципы ООП:
1.Абстракция - когда мы отделяем концепцию от её экземпляра
2.Наследование- способность нашего объекта или класса базироваться на другом объекте или классе(большой класс title(различные статьи на сайте), чуть позже сайт разрастается и нам уже нужно сделать статьи, которые будут 
 под разными рубриками. Соответственно каждая из этих статей будут немножко кастомизироваться, при этом они будут прототипом, на основе которых уже будет что-то создаваться, соотвестственно у нас уже идёт иерархия, где
 есть главный класс title, далее идёт распредление на различные тематики)
////
class ColoredRectangleWithText extends Rectangle{
	constructor(height, width, text, bgColor){
		super();	// метод,который вызывает конструктор родителя(всегда должно быть на 1 месте)
		this.text = text;
		this.color = bgColor;
	}
	showMyprops(){
		console.log(......);
}

КЛАССЫ В РЕАЛЬНОЙ РАБОТЕ:
////
 class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.parent = document.querySelector(parentSelector)
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      element.innerHTML = `
          <div class="menu__item">
            <img src=${this.src} alt=${this.alt} />
            <h3 class="menu__item-subtitle">Меню "Фитнес"</h3>
            <div class="menu__item-descr">
              ${this.descr}
            </div>
            <div class="menu__item-divider"></div>
            <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
            </div>
          </div>
      `
      this.parent.append(element)

    }

  }

  new MenuCard(
    "img/tabs/vegy.jpg",
    "vegy",
    'Меню "Фитнес"',
    'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
    9,
    '.menu .container'
  ).render();
////
- чтобы не прописывать так каждый раз, как мы делали выше, напиешм следующий код:
////
  getResources('http://localhost:3000/menu')
    .then(data => {
      data.forEach(({img, alt, title, descr, price}) => { /* деструктуризация объекта */		//данные о формах будут находиться на сервере
        new MenuCard(img, alt, title, descr, price, '.menu .container').render();
      })
    })
////
- 2-ой варинт без использования классов:
////
  const getResources = async (url, data) => {
    const res = await fetch(url)
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }
    return res.json();
  }
  getResources('http://localhost:3000/menu')
    .then(data => createCard(data));

  function createCard(data) {
    data.forEach(({
     img, altimg, title, descr, price
    }) => {
      const element = document.createElement('div');

      element.classList.add('menu__item');
      element.innerHTML = `
      <img src=${img} alt=${altimg} />
      <h3 class="menu__item-subtitle">Меню "Фитнес"</h3>
      <div class="menu__item-descr">
        ${descr}
      </div>
      <div class="menu__item-divider"></div>
      <div class="menu__item-price">
        <div class="menu__item-cost">Цена:</div>
        <div class="menu__item-total"><span>${price}</span> грн/день</div>
      </div>
      `;
      document.querySelector('.menu .container').append(element);
    })
  }
////
REST-ОПЕРАТОР И ПАРАМЕТРЫ ПО УМОЛЧАНИЮ:
- Синтаксис остаточных параметров функции позволяет представлять неограниченное множество аргументов в виде массива(если ничего не передали, то массив будет пустой)
////
function sum(...theArgs) {
  let total = 0;
  for (const arg of theArgs) {
    total += arg;
  }
  return total;
}
console.log(sum(1, 2, 3));
// expected output: 6
console.log(sum(1, 2, 3, 4));
// expected output: 10
////
- Параметры по умолчанию позволяют задавать формальным параметрам функции значения по умолчанию в случае, если функция вызвана без аргументов, или если параметру явным образом передано значение undefined.
////
function multiply(a, b = 1) {
  return a * b;
}
////
Старый способ:
//// 
function multiply(a, b) {
  b = b || 1;
  return a * b;
}
////

СОЗДАНИЕ ТАЙМЕРА ОБРАТНОГО ОТСЧЁТА НА САЙТЕ:
////

  const deadline = '2022-08-07';

  function getTimeRemaining(endtime) {
    let days, hours, minutes, seconds;
    const t = Date.parse(endtime) - Date.parse(new Date());
    if (t <= 0) {
      days = 0;
      hours = 0;
      minutes = 0;
      seconds = 0;
    } else {
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
        hours = Math.floor(t / (1000 * 60 * 60) % 24),
        minutes = Math.floor((t / 1000 / 60) % 60),
        seconds = Math.floor((t / 1000) % 60);
    }

    return {
      'total': t,
      'days': days,
      'hours': hours,
      'minutes': minutes,
      'seconds': seconds
    };
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds');
    timeInterval = setInterval(updateClock, 1000)

    updateClock(); // чтобы сразу показывало правильное время на странице(в противном случае будет выведено на первую секунду значение по умолчанию deadline)

    function getZero(num) {
      if (num >= 0 && num < 10) {
        return `0${num}`;
      } else {
        return num;
      }
    }

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }


  }

  setClock('.timer', deadline);
////


ЛОКАЛЬНЫЕ СЕРВЕРА:
- Сервер - это программа, которая позволяет запускать сайты и выполнять более сложные операции. Это backend-часть. Там используются серверные языки программирования и также стоят интерпретаторы и эту часть мы не видим.
- Хостинг- это когда мы покупаем определенное место, определённую папку у хостинг-провайдера. Всё, что мы поместим в папку, которая будет записана нашим доменным именем( если оно зарегистрировано), то это всё отобразится
 в интернете. Но чтобы всё это произошло нам необходимо, чтобы хостинг провайдер постоянно имел включённый сервер. 
- Локальные сервера позволяют запустить такой же функционал в пределах нашего комппьютера. 
- Классификация локальных серверов:
	*простые - выполняют несколько задач(live server(только get-запросы), browsersync(только get-запросы), http-сервер(выполняют get и post-запросы, json-сервер) - обновлениепри изменении кода, получение доступа к сайту через wifi-сеть
	*комплексные - выполняют всё, что только можно
JSON-ФОРМАТЫ ПЕРЕДАЧИ ДАННЫХ, ГЛУБОКОЕ КЛОНИРОВАНИЕ ОБЪЕКТОВ:
- JSON-формат - текстовый формат обмена данными, а также формат хранения данных. Изначально появился в JS, однако сейчас используется абсолютно любмы языком программирования.
- это всего лишь набор пар ключ-значение
- все строчки должны быть обязательно в двойных кавычках
- напрямую передавать данные из JS мы не можем, так как сервер и протоколы передачи данных нас не поймут---> нам нужно превратить в нужный формат данные 
- все современные браузеры имеют встроенные объекты json для работы с этими данными и в этом встроенном объекте есть как свойства, так и методы
- методы встроенного объекта json в браузерах:
	*stringify - превращает объект JS в нужный нам формат(будут строчные значения)
	*parse - превращает объект формата JSON в объект формата JS
- причина популярности JSon-формата - это его маленький вес файла + простота чтения даже для человека
- до появления json использовался формат XML
- глубокие копии объектов создаются как раз-таки с помощью методов JSON:
	////
	const clone = JSON.parse(JSON.stringify(persone))
	////

AJAX И ОБЩЕНИЕ С СЕРВЕРОМ:
- для общения с сервером необходимы http-запросы
- чтобы всё это происходилоо асинхронно, то есть без перезагрузки страницы, нужна технология AJAX
- плюсы AJAX:
	*красивая подгрузка отдельных элементов страницы
	*ускорение интерфейса страницы, так как мы не перезагружаем страничку полностью---> уменьшение нагрузки на сервер + экономия траффика пользователя
- минусы AJAX:
	*у пользователя всегда должен быть включён JS
	* при плохом соединении с интернетом может быть некорректное поведение ( что-то может недогрузиться или подвиснуть)
- разница в событиях change и input:
	*change - когда сменяется фокус на форме
	*input - когда что-то вводится или удаляется
- методы объекта XMLHTTPRequest:
	*open(method, url, async, login, pass) - собирает настройки, которые в будущем помогут сделать запрос. Аргументы: method - метол, кот.ю используется для запроса(get или post), url - путь к серверу, async - изначально в позиции 
	 true
- запросы мы посылаем из HTML-файла, именно на нём работают скрипты, поэтому в url указываем путь относительно html
////
const request = new XMLHTTPRequest();
request.open('GET', 'js/current.json') 
////
- http-заголовки:
	*с помощью заголовка мы даём знать серверу какая информация передаётся, как она закодирована(делается это для того, чтобы транспортные протоколы понимали, что они передают и когда они приходят на сервер, сервер
	 точно понимал, что он принимает, что он принимает в себя)
	*заголовок для передачи json-файлов:
	////
	.setRequestHeader('Content-type','application/json; charset=utf-8')
	////
- .send(body) - для отправки запроса(выполняет то, что написали в .open()).Аргумент body - это то, что может уходить на сервер( существует только в post и ещё в паре методов)
- свойства объекта XMLHttpRequest:			
	*status - статсу нашего запроса (например 404(not found))
	*statusText - текстовое описание ответа от сервера
	*response - ответ от сервера(ответ, который нам задал backend-разработчик - то, что мы должны использовать на клиенте)
	*readyState - текущее состояние нашего запроса
- события, относящиеся к объекту XMLHttpRequest:
	*'readystatechange' - отслеживает готовность нашего запроса в данный текущий момент(следит за свойством readyState):
		////
		request.addEventListener('readystatechange', () => {
			if (request.readyState === 4 && request.status ==== 200) {
				console.log(request.respone);
				const data = JSON.parse(request.response);
			} else {
				console.log("Что-то пошгло не так");
			}
		});
		
	*'load' - срабатывает 1 раз, когда запрос уже полностью готов:
		////
		request.addEventListener('readystatechange', () => {
			if ( request.status ==== 200) {			// без request.readyState
				console.log(request.respone);
				const data = JSON.parse(request.response);
			} else {
				console.log("Что-то пошгло не так");
			}
		});
- Реализация скрипта отправки данных на сервер:
////
const forms = document.querySelectorAll('form');
const message = {
	loading: 'Загрузка' ,
	success: 'Спасибо, скоро мы с вами свяжемся' ,
	failure: 'Что-то пошло не так' 
};

forms.forEach(item=> {
	postData(form);
});

	function postData(form) {
		form.addEventListener('submit',(e) => {
			e.preventDefault();

			const statusMessage = document.createElement('div');
			statusMessage.classList.add('status');
			statusMessage.textContent = message.loading;
			form.append(statusMessage);
	
				
			const request = new XMLHttpRequest();
			request.open('POST','server.php');
			
			request.setRequestHeader('Content-type','multipart/form-data');		//!!!!! для объектов XMLHttpReauest() и formData() заголовк утанавливать не нужно, а вот для JSON-файла нужно
			const formData = new FormData(form);					// если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта
		
			request.send(formData);
			
			request.addEventListener('load',() => {
				if (request.status === 200) {
					console.log(request.response);
					statusMessage = message.success;
					form.reset();
					setTimeout(()=> {
						statusMessage.remove();
					}, 2000);
				} else {
					statusMessage = message.failure;
			}
////
ЕСЛИ НУЖЕН JSON-файл--->
////
	const request = new XMLHttpRequest();
			request.open('POST','server.php');
			
			request.setRequestHeader('Content-type','application/json');		
			const formData = new FormData(form);	
			
			const object = {};
			formData.forEach(function(key,value){
				object[key] = value;
			});
			const json = JSON.stringify(object);
				
		
			request.send(json);
////
 //более элегантный способ преображения form-data в json :
        const json = JSON.stringify(Object.fromEntries(formData.entries())) /* берём фоform-data и превращаем в массив массивов--> превращение в обычный объект(обратная операция - 
          fromEntries()---> и далее превращаем объект в json) */
на server.php прописать:
	////
	<?php
	$_POST = json_decode(file_get_contents("php://input"),true);	// только для json-файла
	echo var_dump($_POST);	// эта команда берёт данные, которые пришли на сервер, превращает их в строку и показывает нам обратно на клиенте
	////


КРАСИВОЕ ОПОВЕЩЕНИЕ ПОЛЬЗОВАТЕЛЯ:
////

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/tabs/spinner.svg',
    success: 'Спасибо, скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      const statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display:block;
      margin: 0 auto;
      `
      // form.append(statusMessage); /* в некоторых местах будет некорректно располагаться */

      form.insertAdjacenElement('afterend', statusMessage);
      


      const request = new XMLHttpRequest();
      request.open('POST', 'server.php');

      const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта

      request.send(formData);

      request.addEventListener('load', () => {
        if (request.status === 200) {
          console.log(request.response);
          showThanksModal(message.success);
          form.reset();
          statusMessage.remove();
        } else {
          showThanksModal(message.failure);
        }
      });
    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.style.display = 'none';
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');
    // динамичекси созданные элементы не работают с обработчиками событий, если не прописать через делегирование событий
    thanksModal.innerHTML = `
            <div class="modal__content">
            <div class="modal__close" data-close >×</div>         
            <div class="modal__title">${message}</div>
            </div>
        `;
    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.style.display = "";
      closeModal();
    }, 4000)
  }

});
////

PROMISE:
- позволяет успешно и удобно работать с асинхронными операциями(2 вида асинхр. операций: 1.таймауты; 2. операция с сервером(мы не знаем, когда сервер выполнит её))
- promise - обещания
- если произошло что-то, то мы обещаем, что выполнится какое-то действие
- необходима цепочка действий. Чтобы выполнить промис, нужно, чтобы какое-то действие сначала выполнилось---> для такого кода можно написать множество колбэк вызовов, но он будет нечитабельным
- resolve и reject это как бы условности(это такое соглашение, как я понял). Мы ставим resolve, когда нас устраивает то, что выполнилось в асинхронной операции и reject, если наоборот не устроило
////
const req = new Promise(function (resolve, reject){	// обещание может заверишться как положительно, так и отрицательно
	....						// resolve и reject - это аргументы, вместо которых будут подставляться функции
	const product = {
		name: 'TV',
		price: 2000
	};
	
	resolve(product);
});
							// дальше мы должны обработать все эти варианты
req.then((product) => {					// метод .then() принимает внутри себя аргумент с функцией - resolve
	console.log(data);				//с reject то же самое, только используется метод .catch()
}
////
- с помощью промисов мы добиваемся, чтобы наш код был последовательным, несмотря на то, что он асинхронный
- с помощью метода .finally() прописываются действия, которые должны происходить всегда(при любом исходе промиса)
- Promise.all([....]).then() - метод, который выполняет действие при выполнении всех стоящих в скобках промисов
- Promise.race([....]).then() - метод, который выполняет действие после выполнения первого промиса

Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.

Promise может находиться в трёх состояниях:

ожидание (pending): начальное состояние, не исполнен и не отклонён.
исполнено (fulfilled): операция завершена успешно.
отклонено (rejected): операция завершена с ошибкой.
При создании промис находится в ожидании (pending), а затем может стать исполненным (fulfilled), вернув полученный результат (значение), или отклонённым (rejected), вернув причину отказа. В любом из этих случаев вызывается обработчик, прикреплённый к промису методом then. (Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)
Создание промиса
Объект Promise создаётся при помощи ключевого слова new и своего конструктора. Конструктор Promise принимает в качестве аргумента функцию, называемую "исполнитель" (executor function). Эта функция должна принимать две функции-колбэка в качестве параметров. Первый из них (resolve) вызывается, когда асинхронная операция завершилась успешно и вернула результат своего исполнения в виде значения. Второй колбэк (reject) вызывается, когда операция не удалась, и возвращает значение, указывающее на причину неудачи, чаще всего объект ошибки.

Продвинутый пример
Создать промис!
Copy to Clipboard
<button id="btn">Создать Promise!</button>
<div id="log"></div>
Copy to Clipboard
Данный небольшой пример показывает механизм работы с Promise. Метод testPromise() вызывается при каждом нажатии на <button>. При этом создаётся промис, который успешно выполняется при помощи window.setTimeout, со значением 'result' в случайном интервале от 1 до 3-х секунд.

исполнение промиса протоколируется при помощи продолжения p1.then. Это показывает как синхронная часть метода отвязана от асинхронного завершения промиса.

var promiseCount = 0;
function testPromise() {
  var thisPromiseCount = ++promiseCount;

  var log = document.getElementById('log');
  log.insertAdjacentHTML('beforeend', thisPromiseCount +
      ') Запуск (запуск синхронного кода)
');

  // Создаём промис, возвращающее 'result' (по истечении 3-х секунд)
  var p1 = new Promise(
    // Функция разрешения позволяет завершить успешно или
    // отклонить промис
    function(resolve, reject) {
      log.insertAdjacentHTML('beforeend', thisPromiseCount +
          ') Запуск промиса (запуск асинхронного кода)
');
      // Это всего лишь пример асинхронности
      window.setTimeout(
        function() {
          // Промис исполнен!
          resolve(thisPromiseCount)
        }, Math.random() * 2000 + 1000);
    });

  // Указываем, что сделать с исполненным промисом
  p1.then(
    // Записываем в протокол
    function(val) {
      log.insertAdjacentHTML('beforeend', val +
          ') Промис исполнен (асинхронный код завершён)
');
    });

  log.insertAdjacentHTML('beforeend', thisPromiseCount +
      ') Промис создан (синхронный код завершён)
');
}
Copy to Clipboard
if ("Promise" in window) {
  btn = document.getElementById("btn");
   btn.addEventListener("click",testPromise);
}
else {
  log = document.getElementById('log');
  log.innerHTML = "Live example not available as your browser doesn't support the Promise interface.";
}
Copy to Clipboard
if ("Promise" in window) {
  let btn = document.getElementById("btn");
  btn.addEventListener("click",testPromise);
} else {
  log = document.getElementById('log');
  log.innerHTML = "Демонстрация невозможна, поскольку ваш браузер не поддерживает интерфейс <code>Promise<code>.";
}
- вышеприведённый код выведет: 1) Запуск (запуск синхронного кода)1) Запуск промиса (запуск асинхронного кода)1) Промис создан (синхронный код завершён)1) Промис исполнен (асинхронный код завершён)

Данный пример запускается при нажатии на кнопку. Для этого вам необходим браузер, поддерживающий Promise. При последовательных нажатиях на кнопку с коротким интервалом, вы можете увидеть как различные промиса будут исполнены один за другим.


FETCH API:
- API - это обобщаяющее понятие
- API - по простому, это набор данных и возможностей, которые предоставляют нам какое-то готовое решение
- API - это интерфейс, с которым мы можем работать
- API, который мы знаем - это DOM API - по факту это различные методы, которые позволяют работать с элементами на странице
- FETCH API - технология, позволяющая общаться с ервером и она построена на промисах
////
fetch(url, на который посылаем запрос)			//если больше ничего не указывать, то будет классический GET-запрос  + из этой конструкции возвращается промис
	.then(response => response.json());		// метод .json() - превращает данные в формате json  в самый обычный js-объект    + команда response.json() возвращает нам промис, чтобы мы построили цепочку далее
	.then(json => console.log());
////
- другие виды запросов:
////
fetch(url, на который посылаем запрос, { 
 	method: "POST",
 	body: JSON.stringify({name: 'Alex'}),
	headers: {
		'Content-type': 'application/json'
	}
	});
////
----> теперь вместо XMLHttpRequest мы будем использовать fetch()
////
// ОТПРАВЛЕНИЕ JSON-ФАЙЛА

      const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта

      const object = {};
			formData.forEach(function(key,value){
				object[key] = value;
			});

      fetch('serv1er.php', {
        method: 'POST',
        headers: {
          'Content-type': 'application/json'
        },
        body: JSON.stringify(object)
      })
      .then(data => data.text())    /* прописали это, чтобы чётко понимать какой ответ приходит от сервера */
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      })
      .catch(() => {
        showThanksModal(message.failure);
      })
      .finally(() => {
        form.reset();
      })
 /////         

// ОТПРАВЛЕНИЕ FORM-DATA:

// const formData = new FormData(form); // если в вёртске не указаны атрибуты name , будут скорее всего ошибки при формаровании объекта


// fetch('server.php', {
//   method: 'POST',
//   body:  formData
// })
// .then(data => data.text())    /* прописали это, чтобы чётко понимать какой ответ приходит от сервера */
// .then(data => {
//   console.log(data);
//   showThanksModal(message.success);
//   statusMessage.remove();
// })
// .catch(() => {
//   showThanksModal(message.failure);
// })
// .finally(() => {
//   form.reset();
// })
////

- если внутри fetch() промис попадает на ошибку, которая связана с HTTP-протоколом(404, 502), он не выдаст reject(для него это не считается ошибкой) и нормально выполнит resolve---> reject сработает только если про-
  изойдёт сбой в сети(отключённом интернете) или если что-то помешало запросу выполниться--->2 свойства:
	*.ok - говорит дословно - мы что-то получили и всё окей, либо не окей
	*.status - статус запроса
////
  const getResources = async (url, data) => {
    const res = await fetch(url)
    if(!res.ok){
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }
    return res.json();
  }
////

МЕТОДЫ ПЕРЕБОРА МАССИВОВ:\
- метод .forEach() перебирает массив и НЕ ВОЗВРАЩАЕТ новый 
- каждый последующий возвращает новый массив
- filter:	
////
const names =  ['Ivan', 'Ann', 'Ksenia', 'Voldemart'];
const shortNames = names.filter(name => name.length < 5)
////
- map:	// позволяет взять исходный массив и изменить каждый элемент внутри него
////
const shortNames = names.filter(name => name.toUpperCase());
////
- every/some		// возвращают булиновое значение
	*every - каждый элемент должен соответствовать условию
	*some - хотя бы 1 элемент должен соответствовать условию
////
const some = [4, 'qw', 'dfvdsvsdf'];
some.some( item => typeof(item) === 'number');			// true
////
-reduce:	служит для того, чтобы схлопывать или собирать массив в одно единое целое
////
const arr = [4,5,2,3,1];
const result = arr.reduce((sum, current) => sum + current)	// sum в момент запуска равен первому элементу массива; current тот непосредственный элемент по очереди, который приходит из массива

const str = ['apple', 'android', 'xiaomi']	
const text = str.reduce((sum, current) => `${sum}, ${current}`);
////
	*const result = arr.reduce((sum, current) => sum + current, 3)	// в данном случае sum будет равняться изначально 3
////

-Способ сделать из объекта массив:
////
const newArr =  Object.entries(obj)	// будет массив из массивов



NPM И ПРОЕКТ. JSON-СЕРВЕР:
- желательно устанавливать пакеты локально( для того, чтобы они не работали во всех проектах, чтобы вы знали какая именно версия нужна конкретно для данного проекта, чтобы пользователи, скачивающие ваш проект не ка-
  чали ненужные глобальные пакеты(он будет чётко значть какие именно пакеты ему будут нужны для проекта))
- если пакет будет использоваться только в течение разработки, то ставим флаг --save-dev

ПОЛУЧЕНИЕ ДАННЫХ С СЕРВЕРА. ASYNC/AWAIT(ES8):
////
  const postData = (url, data) => {
    const res = fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'		//Если мы запишем так наш код, то будет ошибка, так как фуцнкция fetch() - асинхронная---> в res будет пусто--->операторы ASYNC/AWAIT
      },
      body: data
    })
    return await res.json();		// в .json() возвращается промис
  }
////
- с помощью операторов async/await мы убираем асинхронность - говорим коду - подожди, пока выполнится эта операция
////

  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {	
        'Content-type': 'application/json'		// ВОТ ТАК ВСЁ БУДЕТ РАБОТАТЬ КОРРЕКТНО 
      },
      body: data
    })
    return res.json();
  }
////


ЧТО ТАКОЕ БИБЛИОТЕКИ. БИБЛИОТЕКА AXIOS:
- библиотека - это маленький участок кода или большой ресурс, который решает какую-либо проблему
- когда вы понимаете, как работает JS  и все его особенности внутри, вам совершенно неважно как выглядит и называется библиотека - они все работают по похожим принципам
- ДЛЯ ИСПОЛЬЗОВАНИЯ БИБЛИОТЕКИ НЕОБХОДИМО ПОМЕЩАТЬ ЕЁ В HTML ПЕРЕД НАШИМ СКРИПТОМ
- axios - удобный ресурс, который позволяет работать с сервером
- в axios есть автоматическое преобразование json-файла
- отличие axios от fetch в том, что возвращает нам более подробный ответ 

СОЗДАНИЕ СЛАЙДЕРА НА СТРАНИЦЕ:
////

  const slides = document.querySelectorAll('.offer__slide'),
  prev = document.querySelector('.offer__slider-prev'),
  next = document.querySelector('.offer__slider-next'),
  total = document.querySelector('#total'),
  current = document.querySelector('#current');
  let slideIndex = 1;

  showSlides(slideIndex);

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`
  } else {
    total.textContent = slides.length;
  }

  function showSlides(n) {
    if (n > slides.length) {
      slideIndex = 1;
    }

    if (n < 1) {
      slideIndex = slides.length;
    }

    slides.forEach(item => item.style.display = 'none')
    slides[slideIndex - 1].style.display = 'block';

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`
    } else {
      current.textContent = slideIndex;
    }

  }

  function plusSlides(n) {
    showSlides(slideIndex += n)
  }

  prev.addEventListener('click', () => {
    plusSlides(-1);
  });


  next.addEventListener('click', () => {
    plusSlides(1);
  });

////



ПРЕДОХРАНИТЕЛИ:
- если при возникновении ошибки , вы используете componentDidCatch, то он не останавливает, как раньше, поломку всего приложения и не выполняет то,что вы написали внутри хука   ---> теперь такого нет и приложение крашится - сделано это было, чтобы не было багов в интерфейсе ---> чтобы перехватывать такие ошибки, нужно использовать ErrorBoundary
- ErrorBoundary - это классовые компонентыЮ, которые оборачивают другие компоненты и если в дочерних компонентах происходит ошибка, то предохранители будут её ловить. При этом приложеие падать  не будет, а ломается лишь этот компонент + если компонент упал, мы можем отрендерить какой-нибудь запасной интерфейс

- если произошла ошибка:
////
  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);			//// чтобы посмотреть её в консоли( 2-ой аргумент - объект ошибки)
    this.setState({
      error: true,
    });
  }
////
- Синтаксис:
//// App.js
            <ErrorBoundary>
              <CharInfo charId={this.state.selectedChar} />
            </ErrorBoundary>
////
//// ErrorBoundary.js
import { Component } from "react";
import ErrorMessage from "../errorMessage/ErrorMessage";

class ErrorBoundary extends Component {
  state = {
    error: false,
  };

  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);
    this.setState({
      error: true,
    });
  }

  render() {
    if (this.state.error) {
      return (
        <h2>
          <ErrorMessage />
        </h2>
      );
    }
    return this.props.children;
  }
}

export default ErrorBoundary;
////

- предохранители ловят далеко не все ошибки - это физически невозможно
- предохранители ловят ошибки при запуске метода рендер, в методах жизненного цикла и в конструкторах дочерних компонентов
- предохранители не ловят ошибки, которые произошли внутри обработчиков событий( потому что события происходят вне метода рендер, так как мы не знаем,когда произойдёт эта операция), в асинхронном коде (логика такая же как и с обработчиками), в самом предохранителе

- есть ещё один метод getDerivedStateFrom - используется в предохранителях наравне с ComponentDidCatch, но его суть в том, что он только обновляет state:
////
static getDerivedStateFromError(error){
	return {error: true};					// кроме возвращения объекта ошибки, он ничего не может делать( по факту это такой setState, который работает только с ошибкой).Он обновляет 				только состояние(никаких логов, никаких сторонних операций здесь не может быть)
}
////



PROPTYPES:
- разрабатывать продукты в статической типизации немного попроще
- одна из настроек в данном ключе назыввается TypeScript(её соединяют с реактом в разработке при необходимости), но это отдельная технология
- другое решение---> технология PropTypes(npm i prop-types --save) 
- теперь мы можем прописывать правило для проверки провпсов
////CharInfo.js
CharInfo.PropTypes = {
  charId: PropTypes.number
};
////
- с помощью PropTypes можно передавать пропсы по умолчанию

ВСТАВКА ЭЛЕМЕНТОВ ЧЕРЕЗ PROPS.CHILDREN:
- в больших приложениях данное свойство нужно для оптимизации
- используется, когда мы не знаем, что именно у нас будет содержаться в определённой оболочке 
////
const DynamicGreeting = (props) = {
	return (
		<div className={'mb-3 p-3 border border-' + props.color}>
			{props.children}
		</div>
	)
}



function App() {
	return (
		<DynamicGreeting color={'primary'}>
			<h2>This weel was hard</h2>			//это будет как {props.children}
			<h2>Hello World!</h2> 
		</DynamicGreeting>

}


- можно сделать что-то с приходящими в props.children элементами динамически:
	*React.cloneElement	(1 - потомок, 2 - те новые пропсы, которые хотим добавить, 3 -children, которые будут передаваться во внутрь компонента)
////
const DynamicGreeting = (props) = {
	return (
		<div className={'mb-3 p-3 border border-' + props.color}>
			React.Children.map(props.children, child => {			// 1-ый аргумент - это элемент или массив из элементов, к которым 									`````````````````````````````````````будет применена callback-функция, 2-ой аргумент - 				            return (										// callback-функция
					React.cloneElement(child, {className: 'shadow'}	// чтобы всё праильно работало, нужно соблюдать принципы 																		   иммутабельности---> нельзя изменять существующий элемент
				})											// ---> нужно его клонировать
		</div>
	)
}
////


СПЕЦИАЛИЗАЦИЯ И НАСЛЕДОВАНИЕ:
- в 99,9% случаев достаточно создавать композицию(совмещение компонентов и придача им новых свойств, функциональности и вида на базе уже существующих - создание более специфичных компонентов) элементов и использовать пропсы(то есть наследование компонентов остаётся не нужным)
- всегда используется композиция, потому что в реакте есть все встроенные возможности для удобного применения композиций( props, к примеру)


RENDER-PROPS ПАТТЕРН:
- не совсем обычный подход
- его можно встретить в работах
- при помощи props.children мы могли управлять элементами динамически---> управлять извне ---> но можно пойти и дальше ---> извне компонента вызывать его render
////
const Message = (props) => {
	return (
		<h2>The counter is {props.counter}</h2>
	)
}

class Counter extends Component {
	state = {
		counter: 0
	}

	change = () => {
		this.setState(({counter}) => ({
			counter: counter + 1
		}))
	}

	render() {
		return (
			<>
				<button
					className={'btn btn-primary'}
					onClick={this.changeCounter}>
					Click me
				</button>
				<Message counter={this.state.counter}/>	// в данном случае это жёсткая привязка(в больших проектах нужен более гибкий 													// способ делать данные вещи, поэтому нам эта 	
			</>										// строчка не подходит
		)
	}
}
////

- как правильно это сделать:
////

class Counter extends Component {
	state = {
		counter: 0
	}

	change = () => {
		this.setState(({counter}) => ({
			counter: counter + 1
		}))
	}

	render() {
		return (
			<>
				<button
					className={'btn btn-primary'}
					onClick={this.changeCounter}>
					Click me
				</button>
				{this.props.render(this.state.counter)}	// вызвали функцию prop-render, при этом для связки компоненты мы передали аргумент
			</>									
		)
	}
}

<Counter render={counter => (	// вызвали prop-render(название может быть любым), которая внутри себя хранит и возвращает другой компонент
	<Message counter={counter}/>
	)}
/>
////
- изначальная задача состояла в том, чтобы создать 2 компонента, которые бы независели друг от друга и мы не теряли их гибкости, 2-ая задача - связать 2 компонента так, чтобы 1 работал внутри другого ---> применили приём - render-props
- главное отличие от prop.children в том, что там мы передавали уже готовые компоненты и элементы, а в render-props мы передаём функцию, которая будет что-то делать и в неё мы можем передавать какие-то аргументы, находящиеся в родительском компоненте



- если твой компонент не знает, что именно будет находиться в нём, то следует использовать эти 2 вышеописанных приёма


ЧТО ТАКОЕ REF И ЗАЧЕМ ОН НУЖЕН:
- ref используются не часто
- используетч  ситуацих, когда мы хотим сделать что-то с дочерним компонентом, не перерисовывая его(постаить или снять фокус, узнать какой текст выделил пользователь и т.д.)
- перед их использованием лучше задаться вопросом: а нельзя ли ввсё сделать классическим образом
- ref - это ссылка на элемент или компонент в Dom-дереве(тоже объект)--->можно использовать DOM API
////
this.myRef = React.createRef();

componentDidMount() {
	this.myRef.current.focus();		//ссылка на элемент хранится в свойстве current
}


render() {
	return(
		<input ref={this.myRef} ..../>
}
////
- так как м работаем напрямую с DOM-деревом(не оптимизированный способ, так как без участия Virtual DOM), то говорят, что лучше, если есть возможность реализовать вашу идею с обычными возможностями реакта, то будет супер
- рефы назначаются перед componentDidMount() и перед componentDidUpdate() 
- отписку от рефов делать не нужно, они автоматически обнуляются
- можно ставить рефы на сами компоненты. Таким образом можно вызывать методы самого компонента
- рефы нельзя назначать на функциональные компоненты, так как они не создают экземпляров(это не классы, они не умеют этого делать) - на них нельзя ссылаться, как я понял
- когда мы назначаем реф на компонент, ссылка идёт конкретно на элемент уже в DOM-структуре, но когда мы используем реф на классовом компоненте, то мы получаем ссылку на экземпляр класса, а это в свою очередь обычный объект и мы не можем использовать на нём стандартный DOM API, но можно, ссылаясь на этот экземпляр с помощью рефа, вызывать методы этого класса


this.myRef = React.createRef();

componentDidMount() {
	this.myRef.current.doSmth();		//ссылка на элемент хранится в свойстве current


render() {
	return(
		<TextInput ref={this.myRef} ..../>
}

class TextInput extends Component {
	
	doSmth = () => {
		console.log('smth');
	}

	render() {
		return (
			<input  ..../>
		)
	}
////

- можно объявлять сколько угодно рефов 
- ещё есть такое понятие как callback-рефы, когда мы создаём их не с помощью createRef, а с помощью функции и записываем ссылку на экземпляр класса:
////
class ... {
	setInputRef = elem => {
		this.myRef = elem		// создание поля this.myRef и помещение ссылки на элемент
	}

	focusFirstTI = () => {
		this.myRef.focus()			//без current!, так как в myRef записывается в данном случае чистая ссылка(не object, а сам элемент, к примеру(если посмотреть через console.dir)

	render() {
		return(
			<input ref={this.setInputRef} ..../>	//в качестве аргумента(elem) берётся тот элемент, на котром была вызвана данная функция 
	}

}
////


ПОРТАЛЫ:
- позволяют отрендерить любые элементы вне своего родительского компонента именно в DOM-структуре(в вёрстке самой страницы)
- для создания портала нужна библиотека ReactDOM
////
const Portal = () => {
	const node = document.createElement('div');
	document.body.appendChild(node);	

	return ReactDOM.createPortal(props.children	, node)		// child - 1-ый аргумент - тот компонент, кот. мы должны отрендерить, 2-ой 
}													// аргумент - тот контейнер, куда мы хотим положить child


<Portal>
	..(наш дочерний элемент)
</Portal>
////
- такой портал можно сделать довольно мощным компонентом по перемещению других элементов(с помощью изменения стилей в componentDidMount)
- события, которые сгенерированы изнутри портала(например, нажатие на элемент внутри портала распространяется и на родителя), будут распространяться и к своему родителю( несмотря на то, что мы, например, сделаем событие для формы(внутри которой будет находиться портал) и в DOM-дереве элемент будет находиться где-то за границей формы, события всё равно будут срабатывать на нашем родительском компоненте): это важно запомнить по 2 причинам---> мы можем назначить событие, которое при срабатывании на этом элементе что-то сломает в форме + в родительском компоненте вы можете работать со своим внешним компонентом, который отделился при помощи портала
- самый главный плюс порталов - в родительском компоненте мы теперь можем работать с внешними компонентами
////

class Form extends Component {

    state = {
        advOpen: false
    }

    handleClick = () => {
        this.setState(({advopen}) => {
            advOpen: !advOpen
        })
    }

    componentDidMount(){
        setTimeout(this.handleClick, 3000)
    }

    render() {
        return (
            <Container>
                <form onClick={this.handleClick} className="w-50 border mt-5 p-3 m-auto" 
                style={{'overflow': 'hidden', 
                        'position': 'relative'}}>
                    <div className="mb-3">
                        <label htmlFor="exampleFormControlInput1" className="form-label">Email address</label>
                        <input  type="email" className="form-control" id="exampleFormControlInput1" placeholder="name@example.com"/>
                    </div>
                    <div className="mb-3">
                        <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                        <textarea className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
                    </div>
                    { this.state.advOpen ?
                            <Portal>
                            <Msg/>
                            </Portal> : null  
                }
                </form>
            </Container>
        )
    }
}

const Portal = (props) => {
    const node = document.createElement('div');
    document.body.appendChild(node);

    return ReactDOM.createPortal(props.children, node);
}

const Msg = () => {
    return (
    <div 
        style={{'width': '500px', 
                'height': '150px', 
                'backgroundColor': 'red', 
                'position': 'absolute', 
                'right': '-50%', 
                'bottom': '-50%'}}>
            Hello
     </div>
     )
    
}
////



"БАНДЛИНГ" И ВЫГРУЗКА ПРОЕКТОВ НА СЕРВЕР:
- в react с помощью команды npm run build мы собираем проект--->появляется папка build - это и есть наша сборка, которую мы будем загружать на сервер, она максимально сжата с помощью различных плагинов



ВВЕДЕНИЕ В ХУКИ:
- хуки появились в react начиная с версии 16.8
- хуки - это функции, которые позволяют делать тоже самое, что и функции в классах, только в функциональных компонентах - это фунции внутри 
  функций - работа с состояниями, с методами жизненного цикла,с рефами - всё это можно сделать на хуках
- причина использования хуков: нарастание синтаксическй сложности при создании большого приложения с помощью классов --->при помощи хуков код становится проще в плане организации 
- принцип хуков построен на js-замыканиях
- правила работы с хуками:
	1. Хуки нужно вызывать только на верхнем уровне(не вызывайте хуки внутри циклов, условий и вложенных функций)
	2. Хуки следует вызывать только из функциональных компонентов реакта(не нужно вызывать их из обычных js-функций и из классов) - есть 	   	   только одно исключение - собственные пользовательские хуки

useSTATE:
- состояния, которые мы записывали в классах теперь будем записывать в наших функциональностях в качестве переменных
- useState() - возвращает массив из 2-ух элементов - 1.state; 2. ф-ия, которая будет менять это состояние
////
const Slider = (props) => {

const [slide, setSlide] = useState(0);			// 0 - значение slide

function changeSlide(i) {
    setSlide(slide => slide + i);				// вызываем callback-функцию, если состояние зависит от предыдыущего, также как и в классах 										   делали
}

const [autoplay, setAutoplay] = useState(0);

function toggleAutoplay() {
    setAutoplay(autoplay => !autoplay)
}



    return (
....
////
- пример объединения состояния:
////
const [state, setState] = setState({slide: 0, autoplay: false});

function changeSlide(){
	setState(state => ({slide: state.slide, ...state}));		//тут, в отличие от классового setState, нужно прописывать все элементы 														  объекта, иначе непрописанные элементы исчезнут
}
////
- но так больше писанины и забот, поэтому почти всегда рекомендуется прописывать состояния отдельно
- при изменении состояния при помощи useState() также идёт перерендеринг всего компонента
- можем прописать так:
////
<button onClick={() => setSlider(false)}>Click</button>	// если setSlider - это второй элемент массива из useState()

useEFFECT:
- это хук работы с эффектами
- эффекты или побоычные действия - это операции по загрузке данных, использованию каких-то сторонних модулей, запуск тайм-аутов, логгирование или тизменение DOM-структур
////
useEffect(()=>{									//функция в скобках запоминается и прикрепляется к этому конкретному компоненту и 												  будет вызвана, когда этот компонент отрендерится и дальше каждый, когда этот 			document.title = `Slide ${slide}`;			  компонент будет обновляться
	
});											// при обнолении компонента, функция внутри useEffect будет создаваться заново и,чтобы 											// не было багов с замыкания(это позволяет получать актуальные данные)--->														   вызывается
////
////
useEffect(() => {
	document.title = `Slide ${slide}`;
}, [slide])							//2-ой аргумент - аргумент заисимости - useEffect вызывается,только если изменился этот аргумент
////
- чтобы получить аналог componentDidMount() - нужно передать в зависимость пустой аргумент
- в классах мы удаляли "подписки" на события с помощью componentWillUnmount()  (а их нужно удалять,чтобы они не засоряли память):
////
function logging(){
	console.log('log');
}
useEffect(() => {
	document.title = `Slide ${slide}`;


	window.addEventListener('click',logging)		// эта строчка ссылается на родительский компонент---> есл компонент необх. удалить, 												   нужно удалить этот обработчик событий 
	return () => {
		window.removeEventListener('click',logging)		//вот так происходит отписка (в данном случае аналог componentWillUnmount)
	}							
}, [slide])										//тут у нас при изменении slide будет происходить отписка
////
- хук useEffect объединил в себе 3 хука жизненного цикла: componentidMount, componentidUpdate, componentwillUnmount


function FriendStatus(props) {
  // ...
  useEffect(() => {
    // ...
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
Этого бага в данном компоненте нет. (Но мы и не изменили там ничего)

Здесь нет никакого особого кода для решения проблем с обновлениями, так как useEffect решает их по умолчанию. Он сбрасывает предыдущие эффекты прежде чем выполнить новые. Чтобы показать это на практике, давайте рассмотрим последовательность подписок и отписок, которые этот компонент может выполнить в течение некоторого времени.

// Монтируем с пропсами { friend: { id: 100 } } 
ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // Выполняем первый эффект

// Обновляем с пропсами { friend: { id: 200 } }
ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // Сбрасываем предыдущий эффект
ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // Выполняем следующий эффект

// Обновляем с пропсами { friend: { id: 300 } }
ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // Сбрасываем предыдущий эффект
ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // Выполняем следующий эффект

// Размонтируем
ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // Сбрасываем последний эффект
Эта логика по умолчанию гарантирует согласованность выполняемых нами действий и исключает баги, распространённые в классовых компонентах из-за упущенной логики обновления.



useCallback:
- когда у нас идёт перерендеринг компонента, всё заново создаётся и вызыается (за исключением некоторых моментов)---> useCallback помогает закэшировать необходимую нам функцию, чтобы она не вызывалась при каждом рендере компонента(useCallback возвращает мемаизированную версию колбэка)
-Мемоизация — в программировании сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.
////
const getImages = useCallback(() => {
	....
}, [slide])
////
- этот приём полезен при передаче дочернему компоненту, который не должен каждый раз меняться
////
const Slider = (props) => {

const [slide, setSlide] = useState(0);
const [autoplay, setAutoplay] = useState(0);

const getSomeImages = useCallback(() => {				// тут реакт(с помощью useCallback) мемайзировал эту функцию(теперь она не будет 													// вызываться повторно при перерендеринге +расположил её в getSomeImages
    return ("http/....")
}, [])

function changeSlide(i) {
    setSlide(slide + i);
}

function toggleAutoplay() {
    setAutoplay(!autoplay)
}



    return (
        <Container>
            <div className="slider w-50 m-auto">
                <Slide getSomeImages={getSomeImages}/>
                <div className="text-center mt-5">Active slide {slide} <br/> {autoplay ? 'auto' : null}</div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={toggleAutoplay}>toggle autoplay</button>
                </div>
            </div>
        </Container>
    )
}

const Slide = ({getSomeImages}) => {
    const [images, setImages] = useState([])

    useEffect(() => {
        setImages(getSomeImages())
    },[getSomeImages])

    return (
        <>
        {images.map(url,i) => <img key={i} className="..." src={url} alt="slide"/>}
        </>
    )
}
//// мы могли  принципе написать этот функционал и с помощью useEffect и useState
-useEffect запускает функцию внутри при изменении массива зависимостей и при этом ничего не возвращает.
-useCallback создает новую функцию при изменении массива зависимостей. И возвращает функцию.
Т.е бывают ситуации, когда нам не надо сразу запускать функцию, именно поэтому мы и используем useCallback
-МЫ МОЖЕМ ВОТ ТАК МЕМАЙЗИРОВАТЬ ФУНКЦИИ В ОСНОВНОМ, КОГДА МЫ ПЕРЕДАЁМ ЭТУ ФУНКЦИЮ ВО ВНУТРЬ ВНУТРЕННЕГО КОМПОНЕНТА(ДОЧЕРНЕГО) - МЫ СДЕЛАЛИ    ЭТО ВЫШЕ
- применяется не так часто

useMemo:
- в отличие от useCallback возвращает меимозированное значение
////
const total = useMemo(() => {
	return countTotal(slide);
}, [slide])
////
- в useMemo нельзя помещать побочные эффекты по типу запросов и подписок, так как этот хук запускается во время рендеринга и может привести к багам
- позволяет избегать повторных вычислений:
////
function App() {
    const [text, setText] = useState('');
    const [posts, setPosts] = useState(data);

    const filteredPosts = useMemo(() => {
        return posts.filter(item => item.name.toLowerCase().includes(text));
    }, [text]);

    const onValueChange = (e) => {
        setText(e.target.value);
    }

    return (
        <>
            <input value={text} type='text' onChange={onValueChange}/>

            <hr/>

            <div>
                {filteredPosts.map(post => (
                    <div key={post._id}>
                        <h4>{post.name}</h4>
                    </div>
                ))}
            </div>
        </>
    );
}
////

useRef:
- рефы существуют и сохраняются при любом перерендеринге компонента, при этом изменение рефа не будет вызывать перерендер
////
const myRef = useRef(null)

return(
	<button ref={myRef}
	....
)
- с помощью useRef удобно сохранять предыдущие состояния:
////
const [text, setText] = useState('');

const ref = useRef(1);

useEffect(() => {
	myRef.current = text
})
return(
		<input onChange={(e) => setText(e.target.value)}>
		<textarea value={myRef.current}	 >				// здесь будет выводиться текст, у которого на одну букву меньше(предыдущее 														// состояние)


СОЗДАНИЕ СОБСТЕННЫХ ХУКОВ:
- собстенные хуки нужны для того, чтобы оптимизировать написание кода(без дублирования кода)
- пользовательские хуки - это механизм повторного использования логики с состоянием
- собственные хуки начинаются с use...
- кастомные хуки можно создавать с любой логикой, в том числе и эффекты
- множество хуков уже готовы и созданы за вас

BATCHING:
- batching - это когда react объединяет несколько изменений состояний в одну операцию для улучшения производительности - это позволяет делать меньше перендеринга компонента и экономить ресурсы компьютера (с 18 версии реакта этот мханизм налажен почти идеально. В более стархы версиях не всегда он работал)
- flushSync - отменяет такое поведение (функция, в которой аргумент - callback-функция)


UseTransition, useDeferredValue и другие нововведения react 18+:
- новый конкурентный режим - теперь реакт внутри себя может выполнять параллельно несколько рендеров или ставить на паузу, давая приоритет чему-то неопределённому и некоторыу другие полезные процессы. Реакт всё сам делает внутри. Например мы что-то печатаем в поле для ввода и вот этот текст приводит к фильтрации товаров--->раньше реакт строго на каждую букву обновлял бы интерфейс с товарами , что приводило бы к глюкам и морганию интерфейса--->теперь же он будет стараться оптимизировать этот процесс, ставя на паузу или откладывая некоторые рендеры, например, перерисовывая инпут сейчас, а товары чуть позже. 
- были введены 1 хука, которые позволяют оптимизировать некоторые задачи и создавать переходы
- пример использования useDeferredValue:
////изначальное было так:
function App() {
    const [text, setText] = useState('');
    const [posts, setPosts] = useState(data);

    const filteredPosts = useMemo(() => {
        return posts.filter(item => item.name.toLowerCase().includes(text));
    }, [text]);

    const onValueChange = (e) => {
        setText(e.target.value);
    }

    return (
        <>
            <input value={text} type='text' onChange={onValueChange}/>

            <hr/>

            <div>
                {filteredPosts.map(post => (
                    <div key={post._id}>
                        <h4>{post.name}</h4>
                    </div>
                ))}
            </div>
        </>
    );
}
- тут будут большие вычисления при вводе в поле текста--->нужна оптимизация--->useDeferredValue:
////
////
function App() {
    const [text, setText] = useState('');
    const [posts, setPosts] = useState(data);
    const deferredValue = useDeferredValue(text);/* теперь вместо того, чтобы использовать текщее состояние текста, будет использоваться отложенно здесь значение */

    const filteredPosts = useMemo(() => {
        return posts.filter(item => item.name.toLowerCase().includes(text));
    }, [text]);

    const onValueChange = (e) => {
        setText(e.target.value);
    }

    return (
        <>
            <input value={text} type='text' onChange={onValueChange}/>

            <hr/>

            <div>
                {filteredPosts.map(post => (
                    <div key={post._id}>
                        <h4>{post.name}</h4>
                    </div>
                ))}
            </div>
        </>
    );
}
- теперь вместо того,чтобы использовать текущее состояние текста, мы будем использовать отложенное значение deferredValue. Это позволяет немного разъединить процессы: когда пользователь что-то вводит в инпут, то меняется текст и текст же меняет value(то есть у нас контролируемый компонент, который перерисовывается каждый раз, когда в него что-то вводят), а вот отфильтрованный массив мы можем отрисовать чуть позже. Действительно, когда пользователь уже закончил ввод(реакт сам решит, когда его отрисовать)
////
- useTransition - 	по своей сути делает то же, что и useDeferredValue, только он предоставляет нам возможность самим указывать, когда начнётся этот процесс, а также позволяет отслеживать состояние этого процесса
////

- флаг isPending позволяет нам отслеживать состояние этого перехода( то есть когда реакт говорит, что ещё не время отрисовывать какие-то данные, то isPending возвращает true)
- запуск перехода происходит при помощи startTransition
- в коде ниже, когда срабатывает onValueChange, то запускается переход, срабатывает функция onValueChange, запускается переход и начинается отложенный рендеринг данных(там, где filteredPosts.map)
function App() {
    const [text, setText] = useState('');
    const [posts, setPosts] = useState(data);
    const [isPending, startTransition] = useTransition();

    const filteredPosts = useMemo(() => {
        return posts.filter(item => item.name.toLowerCase().includes(text));
    }, [text]);

    const onValueChange = (e) => {
        startTransition(() => {
            setText(e.target.value);
        })
        
    }

    return (
        <>
            <input value={text} type='text' onChange={onValueChange}/>

            <hr/>

            <div>
            {isPending ? <h4>loading...</h4> :
                {filteredPosts.map(post => (
                    <div key={post._id}>
                        <h4>{post.name}</h4>
                    </div>
                ))}}
            </div>
        </>
    );
}
////
- 2 вышеприведённых хука следует использовать, когда у вас есть какой-то динамический список данных и с какими-то операциями(фильтрация) , с динамическими подсказками и с табами. В общем стоит применять там, где можно выполнять рендер отложенно	


НАВИГАЦИЯ В ПРИЛОЖЕНИИ, REACT ROUTER V5+:
- в одностраничном приложении может очень много страниц, просто загружаются они без перезагрузки страницы и без перехода по ссылке. В классическом же сайте у нас каждая отдельная страница это php или html-файл, который отвечает за определённый файл html. В веб-приложениях на месте старой страницы у нас просто будет создаваться новый интерфейс прямо через JS - по простому маршрутизация(routing) - это и есть переключение между такими частями приложения
- reactRouter - отдельная библиотека, отвечающая за routing - npm i react-router-dom
////
return (
      <Router>{/* делается для того, чтобы были рабочими все ссылки и все страницы, на которые будут ссылаться эти ссылки внутри одного компонента  По сути тут <Router> - это такой маршрутизатор, который будет получать сигналы от ссылок и показывать нужную нам страницу.Тут AppHeader - это ссылка, а все остальные компоненты - это страницы*/}
        <div className="app">
        <AppHeader />
        <main>
          {/* <ErrorBoundary>
            <RandomChar />
          </ErrorBoundary>
          <div className="char__content">
            <ErrorBoundary>
              <CharList onCharSelected={onCharSelected} />
            </ErrorBoundary>
            <ErrorBoundary>
              <CharInfo charId={selectedChar} />
            </ErrorBoundary>
          </div> */}
		<AppBanner/>
          <ComicsList/>
          <img className="bg-decoration" src={decoration} alt="vision" />
        </main>
      </div>
      </Router>
    );
  }
- Route - именно этот компонент будет грузиться, если в url-адресе появится определённая ссылка. В вышеприведённом коде рута у нас 2
- с помощью атрибута path указываем, какие url-адреса будут отслеживать каждые из маршрутов
- композиция - это когда подгружаются комбинированные компоненты, библиотека reactRouter позволяет это сделать. reactRouter сравнивает строку в path не строго, а по частям--->может легко загрузить несколько компонентов, когда нам это совсем не нужно--->на помощь приходит еомпонент switch
- Router отслеживает совпадение с url-адресом у path по частям - если path будет состоавляющей url-адреса, то Router отрендерит соответствующий компонент
- компонент switch необходим, чтобы реакт загужал только необходимый нам компонент, а не всё подряд.Он смотрит на руты детей и рендерит первое попавшееся совпадение с url(но совпадение не строгое - 1-ый способ избежать данной особенности библиотеки - прописать главную страницу в самом конце содержимого свича ; 2-ой способ - использование атрибута exact в руте - он говорит, что только полное совпадение пути будет рендерить этот компонент)
- прописываем ссылки:
////
import { Link } from "react-router-dom";
import "./appHeader.scss";

const AppHeader = () => {
  return (
    <header className="app__header">
      <h1 className="app__title">
        <Link to="/">
          <span>Marvel</span> information portal
        </Link>
      </h1>
      <nav className="app__menu">
        <ul>
          <li>
            <Link to="/">Characters</Link>
          </li>
          /
          <li>
            <Link to="/comics">Comics</Link>
          </li>
        </ul>
      </nav>
    </header>
  );
};
////
- Link - это всё та же модифицированная ссылка, в html этот компонент отображается как тэг <a></a>
- когда мы кликаем на ссылку, наш компонент <Router> замечает это изменение--->начинает искать подходящий Route
- другие атрибуты:
	*Redirect - позволяет перенаправлять страницу по определённому адресу - его можно использовать внутри условий
	*NavLink - делает то же самое, что и обычной Link, но он отличается возможностью стилизации активной ссылки
////
            <NavLink exact activeStyle={{'color': '#9f0013'}} to="/">Characters</NavLink>
          </li>
          /																	//exact нужен, чтобы не окрашивались в цвет обе ссылки	
          <li>
            <NavLink exact activeStyle={{'color': '#9f0013'}} to="/comics">Comics</NavLink>
////

REACT ROUTER V6+:
- вместо switch используется routes - он мощнее свича, онпозволяет по более очевидному алгоритму сравнивать атрибуты path, теперь не нужен атрибут exact(его уже не существует)
////
return (
        <Router>{/* делается для того, чтобы были рабочими все ссылки и все страницы, на которые будут ссылаться эти ссылки внутри одного компонента  По сути тут <Router> - это по сути такой маршрутизатор, который будет получать сигналы от ссылок и показывать нужную нам страницу.Тут AppHeader - это ссылка, а все остальные компоненты - это страницы*/}
          <div className="app">
          <AppHeader />
          <main>
           <Routes>
           <Route  path="/" element={<MainPage/>}/>
            <Route  path="/comics" element={<ComicsPage/>}/>
           </Routes>
          </main>
        </div>
        </Router>
      );
////
- компонент Outlet - это плэйсхолдер, куда мы помещаем дочерние компоненты(используется, когда мы используем вложенные руты(когда используем композицию компонентов))
////
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="users" element={<Users />}>
          <Route path="me" element={<OwnUserProfile />} />
          <Route path=":id" element={<UserProfile />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function Users() {
  return (
    <div>
      <nav>
        <Link to="me">My Profile</Link>
      </nav>

      <Outlet />
    </div>
  );
}
////
- ссылки внутри маршрутов всегда будут относиться к пути этого роута( в отличие от v5)
////
function App() {
  return (
    <Routes>
      <Route path="users" element={<Users />}>
        <Route path=":id" element={<UserProfile />} />
      </Route>
    </Routes>
  );
}

function Users() {
  return (
    <div>
      <h2>
        {/* This links to /users - the current route */}
        <Link to=".">Users</Link>
      </h2>

      <ul>
        {users.map((user) => (
          <li>
            {/* This links to /users/:id - the child route */}
            <Link to={user.id}>{user.name}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}

function UserProfile() {
  return (
    <div>
      <h2>
        {/* This links to /users - the parent route */}
        <Link to="..">All Users</Link>
      </h2>

      <h2>
        {/* This links to /users/:id - the current route */}
        <Link to=".">User Profile</Link>
      </h2>

      <h2>
        {/* This links to /users/mj - a "sibling" route */}
        <Link to="../mj">MJ</Link>
      </h2>
    </div>
  );
}
////
- useNavigate - используется вместо хука useHistory
- атрибут exact переименован в end
- атрибуты activeClassName и activeStyle были убраны из библиотеки--->теперь в атрибут style должны передавать функцию, которая будет этим заниматься 
////
<NavLink end 
            style={(isActive)=>{color: isActive ? '#9f0013' : 'inherit'}} to="/">Characters</NavLink>
////	

ПРАКТИКА СОЗДАНИЯ ДИНАМИЧЕСКИХ ПУТЕЙ:
- способы избавления от пустой страницы при неправильном url:
1.помещаем базовый Route в конец списка без уточняющего атрибута exact
2. с помощью собственного компонента, который помещаем в конец:
////
                        <Route path="*">
                            <Page404/>
                        </Route>
////
- динамическое формирование страницы по клику:
////
////
- у Router DOM внутри есть три объекта;
	1.match - объект с данными о том, как именно path совпал с данными текущего адреса и в нём же есть вот тот параметр id, который мы передавали(params)
	2.history - API для организации перехода между страницами - нужно для того, чтобы перенаправлять пользователя по ссылочкам
	3.location - это состояние и положение нашего футера
	

-useParams:
The concept of parameters is not limited to function declarations. When working with React router, there are URL parameters similar to the function parameters described above. In React router, URL parameters are placeholders you declare in a route, as in the example below.

<Routes>
  <Route path="/blog/:id" element={<Blog />} /> 
</Routes>

In the example above, id is a placeholder because of the : in front. The placeholder is known as the URL parameter. Because of the URL parameter, React router will not literally match the route above with the URL. It will dynamically match if you point the browser to a URL that matches the /blog/:id pattern in its path.

Assuming you are hosting the site on https://refine.dev/, pointing the browser to https://refine.dev/blog/use-params will match the route above. As a result, the id parameter will take the value "use-params" in the Blog component.

The section below will explain how you can access the URL parameter in the rendered Component using the useParams hook.

How to use the useParams hook
As explained in the section above, you can declare a route with URL parameters so that React router dynamically captures the corresponding values in the URL when there is a match. It is useful when dynamically rendering the same component for multiple paths.

<Routes>
  <Route path="/blog/:id" element={<Blog />} /> 
</Routes>

Assuming you have the route above in your React router setup, you can retrieve the route parameters in the Blog component using the useParams hook. It returns an object. The object keys are the parameter names declared in the path string in the Route definition, and the values are the corresponding URL segment from the matching URL.

You can use the useParams hook in the rendered component to retrieve the parameters like so:

import { useParams } from "react-router-dom";

const Blog = () => {
  const routeParams = useParams();
};

If the matching route is/blog/use-params for the example above, the useParams hook will return the object below. You can then use the returned object in the rendered Component the way you want.

{
  id: "use-params"
}

////

ДИНАМИЧЕСКИЕ ИМПОРТЫ И REACT.LAZY:
- пора задуматься об разделении приложения на отдельно загружающиеся кусочки: допустим у нас 10 страниц---> при первом запуске нам не нужно загружать их все сразу, мы хотим делать это только при необходимости, чтобы начальная сборка не содержала этого кода---> здесь могут помочь динамические импорты
- до этого момента мы прописывали только статические импорты 
- динамаческий импорт всегда возвращает промис с объектом модуля 
////
if (loading) {
	import('./someFunc')	// someFunc.js	(содержит в себе экспортируемую функцию logger(которая будет являться свойством объекта, возвращающегося в promise)			
		.then(obg => obj.logger())
		.catch()
////
- если в импортируемом файле несколько функций:
//// SomeFunc.js
export function logger() {
	console.log('Hello world');
}

export function secondLog() {
	console.log('2nd');
}
////другой файлик
const onCharListLoaded = async () {
	
	const {logger, secondLog} = await import('/SomeFunc');		//чтобы вытащить наши функции, мы должны воспользловаться асинхронным синтаксисом деструктуризации. Так как 		   операция асинхронная(когда мы идём к файлу, мы не знаем через сколько код отдаст наш результат(мы получаем промис именно поэтому), то мы должны использовать await
	logger();
	....
}
////
- экспорт по дефолту:
////SomeFunc.js
export default function logger() {// экспорт по умолчанию
	console.log('Hello world');
}
export function secondLog() {	//именованный экспорт
	console.log('2nd');
}
////другой файлик
if (loading) {
	import('./someFunc')	// 	
		.then(obg => obj.default())			// обращение к logger
		.catch()							// теперь импортируемый объект будет выглядеть следующим образом:
										{
											default: () {
												console.log('Hello world');
													}

										}
////
- это были способы для нативного JS---> в реакте есть свой способ осуществлять такую динамическую подгрузку - ещё она называется ленивой подгрузкой---> это вылилось в метод, который называется React.lazy - по своему действию этот метод будет загружать компонент в бандл только тогда, когда компонент будет впервые отрендерен
- есть несколько ньюансов:
	1. Этот компонент, который будет лениво подгружаться, должен быть экспортирован по умолчанию
	2. Когда в нативном JS мы могли обработать ошибку динамического импорта через блок catch, то здесь мы с вами сделать этого не можем---> поэтому 2-ым обязательным условием является использование компонента Suspense, который и будет отвечать за ошибки в импортах и отображение запасного содержимого(мы просто должны создать один компонент уже встроенный в реакт, который оборачивает тот ленивый компонент, который подгружаться будет динамически)---> обычно берут всю структуру, которая есть в у нас в приложении и оборачивают в <Suspense></Suspense>
- Suspense принимает в себя 1 обязательный атрибут fallback={} - запасной компонент, который можно показать, пока грузится импорт 
////
<Router>
            <div className="app">
                <AppHeader/>
                <main>
                    <Suspense fallback={<span>Loading...</span>}>
                        <Switch>
                            <Route exact path="/">
                                <MainPage/>
                            </Route>
                            <Route exact path="/comics">
                                <ComicsPage/>
                            </Route>
                            <Route exact path="/comics/:comicId">
                                <SingleComicPage/>
                            </Route>
                            <Route path="*">
                                <Page404/>
                            </Route>
                        </Switch>
                    </Suspense>
                </main>
            </div>
        </Router>
////
- динамические импорты прописываются только после статических импортов
- после такой оптимизации размер файла после "билда" будет БОЛЬШЕ, чем раньше - это значит, что такая оптимизация не ведёт к тому, что у вас будет меньше кода по размеру. Но есть ещё 1 момент--->когда мы зайдём в наш "сбилденный" файл build/static/js можно увидеть, что количество файлов у нас резко возросло--->получается и файлов больше и размер суммарный больше(как так??!), но дело не в этом, а в том, как будет работать наше приложение--->когда мы оптимизируем наше приложение при помощи ленивых компонентов у нас иначально грузится намного меньше участка кода и только тогда, когда мы переходим по страницам, у нас догружаются отдельные кусочки файлов, которые являются отдельными компонентами--->это значит, что общий вес первого бандла, который подгрузится изначально, когда пользователь только заходит в приложение будет намного меньше--->оптимизация прошла успешно
- лучше сильно не увлекаться ленивой загрузкой если у вас небольшие, несложные страницы, да и приложение маленькое, то особого смысла нет в этих операциях
- лениво грузить можно не только страницы, но и абсолютно любой компонент, который у вас есть на странице
		

REACT.MEMO, REACTCOMPONENT И ОПТИМИЗАЦИЯ СКОРОСТИ РАБОТЫ ПРИЛОЖЕНИЯ:
- React.memo - необходим только для оптимизации - он будет мемоизировать некоторые компоненты
- возьмём случай, когда у нас есть компонент, который принимает в просах один и тот же по содержанию объект, но для JS этот новый получаемый объект в пропсе по сравнению с предыдущим объектом в пропсе будет отличаться, так как сравнение идёт по ссылкам, а не по значению--->будет идти перерендер, так как обновились пропсы--->бесполезный перерендер компонента--->React.memo позволяет избежать этих лишних перерендеров, но это распространяется только в случае пропсов
////
const MyComponent = React.memo(function MyComponent(props) {
  /* рендер с использованием пропсов */
});
////
////
const Form = memo((props) => {
    return (
        <Container>
            <form className="w-50 border mt-5 p-3 m-auto">
                <div className="mb-3">
....

function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text'
    });


    return (
        <>
            <Form mail={data.mail} text={data.text}/>
            <button 
                onClick={() => setData({
                    mail: "second@example.com",				// приходит такой же по значению объект, но он всё равно отличается от предыдущего пропса
                    text: 'another text'
                })}>
                Click me
            </button>
        </>
    );
}
////
- функция memo - компонент высшего порядка
- сравнение пропсов идёт только по верхнему уровню!(сравнение поверхностное)! ---> напоминание: поверхностная копия - это когда копия создаётся только на верхнем уровне вложенности, а на уровнях ниже уже идут ссылки на объект родителя. Здесь похожая ситация - сравнение в просах идёт только по верхнему уровню:
////
function App() {
    const [data, setData] = useState({
        mail: {
            name: "name@example.com"
        },
        text: 'some text'
    });


    return (
        <>
            <Form mail={data.mail} text={data.text}/>
            <button 
                onClick={() => setData({
                    mail: {
                        name: "name@example.com"		// теперь у нас пропс получается комплексным, мы будем как mail передавать объект 
                    },
                    text: 'another text'
                })}>
                Click me
            </button>
        </>
    );
}
////---> тут у нас будет перерендериваться при нажатии на click me, несмотря на memo - происходит это потому что функция memo думает, что это уже другой пропс лежит внутри mail,
 потому что, когда мы вызывали setData в mail был создан новый объект, который содержит те же данные внутри и функция memo думает, что это уже другой объект, потому что у неё внутри механизм поверхностного сравнения, потому что она сравнивает только свойства mail и text. Она видит, что внутри у нас тот же объект, но ссылка на него уже другая---> нужно перерендерить компонент--->при таких глубоких конструкциях memo будет работать неправильно--->	для таких случаев можно написать свою функцию сравнения(она подставялется вторым аргументов в функцию memo(первый аргумент это сам компонент)):
////
function propsCompare(prevProps, nextProps){
    return prevProps.mail.name === nextProps.mail.name && prevProps.text === nextProps.text
}

const Form = memo((props) => {
    return (
        <Container>
            <form className="w-50 border mt-5 p-3 m-auto">
                <div className="mb-3">
                    <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
                    <input value={props.mail.name} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
                    </div>
                    <div className="mb-3">
                    <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                    <textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
                </div>
            </form>
        </Container>
    )
},propsCompare)
////
- memo обычно используют чаще всего при запросах на сервер через определённый промежуток времени: допустим вы пишите приложение, которое отображает курс криптовалют с шагом в 5 или в 1 секунду. Если курс не меняется, то и смысла перерисовывать компонент не имеет смысла.
- всё, что мы учили до memo точно также работает и для классовых компонентов ( и маршрутизация, и ленивая загрузка), но вот с memo немного другая ситуация.По факту мы можем спокойно обернуть класс этим методом и это может даже работать, но такой подход не очень оптимизирован и может вызвать баги , поэтому необходимо использовать такой компонент, как PureComponent (он к тому же учитывает одинаковые состояния)
- PureComponent  похож на React.Component, но в React.PureComponent есть shouldComponentUpdate()?? - он всё делает самостоятельно(в отличие от простого использования Component).
Сравним Component  и PureComponent:
////Component
class Form extends Component{

    shouldComponentUpdate(nextProps){
        if(this.props.mail.name === nextProps.mail.name){
            return false							// если нет изменений, то повторного рендеринга не будет
        } return true
    }
    render(){

  
            console.log('render');
            
            return (
                <Container>
                    <form className="w-50 border mt-5 p-3 m-auto">
                        <div className="mb-3">
                            <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
                            <input value={this.props.mail.name} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
                            </div>
                            <div className="mb-3">
                            <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                            <textarea value={this.props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
                        </div>
                    </form>
                </Container>
            )
            }
    
}
////PureComponent
class Form extends PureComponent{		// PureComponent всё делает сам
    render(){

  
            console.log('render');
            
            return (
                <Container>
                    <form className="w-50 border mt-5 p-3 m-auto">
                        <div className="mb-3">
                            <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
                            <input value={this.props.mail.name} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
                            </div>
                            <div className="mb-3">
                            <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                            <textarea value={this.props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
                        </div>
                    </form>
                </Container>
            )
            }
    
}
////
- в классовых компонентах мы можем использовать как пропсы, так и стэйты---> как сравнивать стэйты в функциональных компонентах--->можно передавать стэйт в качестве пропсов
- не стоит мемоизировать компоненты в маленьких приложениях
- есть обратная сторона медали: если вы начнёте применять memo к компонентам, которые постоянно получают разные пропсы,то вы добавляете дополнительные действия и замедляете своё приложение(при изменении мы добавляем одно промежуточное действие - сравнение между предыдущими и нрвыми пропсами и если у нас данные часто будут другие, то вот это промежуточное действие будет каждый раз замедлять рендеринг компонента)
- ещё один момент - если в качестве пропсов передавать функцию, то при сравнении пропсов они всегда будут разные, так как функция это объект, а функция при перерендеринге всегда  создаётся заново:
////
function App() {
    const [data, setData] = useState({
        mail: {
            name: "name@example.com"
        },
        text: 'some text'
    });
		
    const onLog = ()=>{			// вот тут	
        console.log('wow')
    }

    return (
        <>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button 
                onClick={() => setData({
                    mail: {
                        name: "name@example.com"
                    },
                    text: 'another text'
                })}>
                Click me
            </button>
        </>
    );
}
////--->чтобы исправить эту ошибку используем useCallback()
////
function App() {
    const [data, setData] = useState({
        mail: {
            name: "name@example.com"
        },
        text: 'some text'
    });

    const onLog = useCallback(()=>{
        console.log('wow')
    },[])

    return (
        <>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button 
                onClick={() => setData({
                    mail: {
                        name: "name@example.com"
                    },
                    text: 'another text'
                })}>
                Click me
            </button>
        </>
    );
}
////


REACT CONTEXT И USECONTEXT:
- есть 3 способа построения приложения:
	1.где использовали одно общее состояние в главном файле, а потом прокидывали его методы для изменения этого состояния всё ниже по иерархии компонентов
	2.где каждый компонент хранил своё личное состояние и менял его по своему усмотрению
	3.где есть одно общее состояние, но при этом каждый компонент может с ним взаимодействовать без целой кучи прокинутых пропсов
- какой способ использовать? Всё ситуативно, смотря какое перед нами приложение
- контекст иногда используют как третий вариант построения приложения с одним общим состоянием
- контекст нужен для того, чтобы определённые данные передавать ниже по иерархии компонентов, не используя пропсы
////
<Page user={user} avatarSize={avatarSize} />
// ... который рендерит ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... который рендерит ...
<NavigationBar user={user} avatarSize={avatarSize} />			//тут мы видим как делать не надо, т.к. пропсы гуляют по всем компонентам сверху вниз - это антипаттерн
// ... который рендерит ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>
////
const dataContext = createContext({			
    mail: {
        name: "name@example.com"
    },
    text: 'some text'
});    //единственный аргумент, эта команда принимает значение по умолчанию 
////
- посмотрим на этот объект изнутри:
////
console.dir(dataContext);	
выведет следующее:
Object
$$typeof
: 
Symbol(react.context)
Consumer: {$$typeof: Symbol(react.context), _context: {…}, …}	//
Provider: {$$typeof: Symbol(react.provider), _context: {…}}
_currentRenderer: null
_currentRenderer2: null
_currentValue: {mail: {…}, text: 'some text'}
_currentValue2: {mail: {…}, text: 'some text'}
_defaultValue: null
_globalName: null
_threadCount: 0
[[Prototype]]: Object

--->Provider - компонент, который нужен для того, чтобы предоставлять значения компонентам, которые находятся ниже по иерархии(без пропсов!)
--->Consumer - компонент, который позволяет получить эти данные и он же подписывается на изменение в контексте
- чаще всего две вышепречисленные сущности выдёргивают при помощи деструктуризации из контекста 
////
const {Provider, Consumer} = createContext({
    mail: {
        name: "name@example.com"
    },
    text: 'some text'
});

function App() {
    const [data, setData] = useState({
        mail: {
            name: "name@example.com"
        },
        text: 'some text'
    });

    const onLog = useCallback(()=>{
        console.log('wow')
    },[])

    return (
		<Provider value={data}>		// value - с помощью него передаём те данные, которые будут доступны по иерархии ниже
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button 
                onClick={() => setData({
                    mail: {
                        name: "name@example.com"
                    },
                    text: 'another text'
                })}>
                Click me
            </button>
          </Provider>
- все потребители у потомка Provider будут перерендериваться, как только prop.value будет у провайдера меняться
////
class InputComponent extends Component{				// на 2 ступени ниже чем App, но принимает значение value.mail с помощью контекста	
    render() {
        return(
            <Consumer>
                {
                    value => {							// value - это то, что сидит в <Provider value={data}>
                        return(
                            <input 
                            value={value.mail} 
                            type="email" 
                            className='form-control' 
                            id="exampleFormControlInput1" 
                            placeholder="name@example.com"/>
                        )
                    }
                }
            </Consumer>
        )
    }
}
- вышеприведённое было первым вариантом использования контекста в классовом компоненте
- второй способ(также в классах):
////
1)либо так
class InputComponent extends Component{

                    // здесь для класса мы можем назначить определённое свойство, которое будет сразу привязывать к определённому контексту - это статичные свойства
    render() {
        return(
            <input 
                            value={this.context.mail} 
                            type="email" 
                            className='form-control' 
                            id="exampleFormControlInput1" 
                            placeholder="name@example.com"/>
        )
    }
}

InputComponent.contextType = dataContext;   // теперь у нас в нашем классе есть свойство класса - context

const dataContext = createContext({
    mail: {
        name: "name@example.com"
    },
    text: 'some text'
});    //единственный аргумент эта команда принимает значение по умолчанию ///
////
2)либо вот так - при помощи слова static(более удобный синтаксис)
class InputComponent extends Component{

    static contextType = dataContext;              // здесь для класса мы можем назначить определённое свойство, которое будет сразу привязывать к определённому контексту - это 											 статичные свойства
    render() {
        return(
            <input 
                            value={this.context.mail} 
                            type="email" 
                            className='form-control' 
                            id="exampleFormControlInput1" 
                            placeholder="name@example.com"/>
        )
    }
}
////
- теперь рассмотрим функциональные компоненты - для этого используется useContext
////
const dataContext = createContext({
    mail: {
        name: "name@example.com"
    },
    text: 'some text'
}); 

const InputComponent = () => {

    const context = useContext(dataContext) // аргумент - тот контекст, на который мы подписываемся


        return(
            <input 
                            value={context.mail} 
                            type="email" 
                            className='form-control' 
                            id="exampleFormControlInput1" 
                            placeholder="name@example.com"/>
        )
}
////
-далее могут появиться следующие вопросы:
	1.Если компоненты у нас находятся в разных файлах, тоо как с ними взаимодействовать--->используем те же самые импорты-экспорты файлов(как правило контекст хравнится в отдельном файлике и компоненты естественно тоже--->далее просто импортируем их)
	2.Может ли приложение использовать больше одного контекста? Конечно, каждый контекст может давать доступ к определённым данным
	3.Могу ли я вот эти вот данные, которые расположены в контексте как-то изменять с помощью методов?/ Да, можно, НО! чтобы не было ошибок, нужно вносить эти методы в значения 	  по умолчанию(это желательно), чтобы не было никаких багов( так как, если мы уберём <Provider>, то этого метода компонент знать не будет---> ошибка)
////
const dataContext = createContext({
    mail: {
        name: "name@example.com"
    },
    text: 'some text',
    forceChangeMail: () => {}       // даже пустая функция сойдёт 
});    //единственный аргумент эта команда принимает значение по умолчанию 

function App() {
    const [data, setData] = useState({
        mail: {
            name: "name@example.com"
        },
        text: 'some text',
        forceChangeMail: forceChangeMail
    });

    function forceChangeMail() {                        // вот тут создаём метод, который далее будет использовать в контексте для изменения данных контекста
        setData({...data, mail: 'test@gmail.com'})  
    }

    return (
        <Provider value={data}>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button 
                onClick={() => setData({
                    mail: {
                        name: "name@example.com"
                    },
                    text: 'another text',
				 forceChangeMail: forceChangeMail
                })}>
                Click me
            </button>
        </Provider>
    );
}

const InputComponent = () => {

    const context = useContext(dataContext) 

        return(
            <input 
                            value={context.mail} 
                            type="email" 
                            className='form-control' 
                            id="exampleFormControlInput1" 
                            placeholder="name@example.com"
                            onFocus={context.forceChangeMail}/>     //используем этот метод
        )
}
////
- нельзя использовать <Provider> без value, потому что в таком случае значение value будет undefined и в том месте, где контекст будет использоваться, произойдёт ошибка---> значение по умолчанию вообще устанавливается (
const dataContext = createContext({
    mail: {
        name: "name@example.com"
    },
    text: 'some text'
})      
) тогда, когда у нас полностью отсутствует <Provider></Provider>---> значение по умолчанию работает тогда, когда провайдера не существует
- когда предаём контекст, нужно стараться не передавать в value прямых объектов---> это может привести к небольшим проблемам с оптимизацией: если наш провайдер заново перерендерится, то обновятся все компоненты, которые на него подписаны, потому что у нас заново создаётся новый объект, который не равен предыдущему

USEREDUCER:
- это альтернатива useState 
////
const [autoplay, dispatch] = useReducer(reducer, false);// в левой части второй аргумент - функция, которая будет меняться наш стэйт(как правило называют её dispatch(без крайней надобности изменять её не стоит)) 1-ый аргумент - это ОБЪЕКТ(так как reducer возвращает всегда объект)
////
- dispatch отвечает за вызов изменения 
- dispatch принимает 3 аргумента:
	1.функцию reducer - отвечает за модификацию состояния(не вызов изменения, как это делает dispatch). Состоит из 2-у аргументов: 1.state - текущее состояние, которая находится на момент до его изменения;2. action - название того действия, которое мы хотим совершить 
	2.начальное состояние
	3.для ленивого создания начального состояния
////
() => dispatch({type: 'slow'})    // аргумент - это объект со свойством type. Этот объект будет передаваться в функцию reducer в качестве второго аргумента(action)
////
- логика работы:
	*у нас есть dispatch, она инициализирует изменение(когда, например, мы нажимаем на кнопку)--->она принимает 1 большой аргумент в виде объекта(action) - действие, которое долэно выполниться с этим состоянием - дословно - мы прописываем внутри тип действия--->далее запускается функция reducer--->она принмиает 2 аргумента - 1-ая - текущий state, 2-ой - action - тот объект, который приходит при вызове нашего dispatch--->дальше при помощи switch-case она определяет, какое действие нужно выполнить, причём возвращаем из функции reduce объект, то есть в state будет записываться объект---> новое значение в state
////
function reducer(state, action){ 
    switch (action.type){
        case 'toggle' :
            return {autoplay: !state.autoplay}
        case 'slow' :
            return {autoplay: 300}
        case 'fast' :
            return {autoplay: 700}
        default: 
            throw new Error();
    }
}

const Slider = () => {
    const [slide, setSlide] = useState(0);
    // const [autoplay, setAutoplay] = useState(false);
    const [autoplay, dispatch] = useReducer(reducer, {autoplay: autoplay});// в левой части второй аргумент - функция, которая будет меняться наш стэйт(как правило называют её dispatch(без крайней надобности идзменять её не стоит))

    function changeSlide(i) {
        setSlide(slide => slide + i);
    }

    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {slide} <br/>{autoplay.autoplay ? 'auto' : null} </div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'toggle'})}>toggle autoplay</button>
                                            <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'slow'})}>toggle autoplay</button>
                                            <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'fast'})}>toggle autoplay</button>
                </div>
            </div>
        </Container>
    )
}
////
- 3-ий аргумент в useReduce - эта функция, которая лениво создаёт начальное значение(в функции init будет записываться то, что как мы хотим изменить наше значение при начальной инициализации). Это может быть полезно в асинхронных операциях или после определённого действия:
////
function init(initial){					//!!!!
    return {autoplay: initial }// должен создавать объект , который будет содержать то начальное состояние, которое мы хотим использовать 	//!!!!
}

const Slider = ({initial}) => {
    const [slide, setSlide] = useState(0);
    // const [autoplay, setAutoplay] = useState(false);
    const [autoplay, dispatch] = useReducer(reducer, initial, init);// в левой части второй аргумент - функция, которая будет меняться наш стэйт(как правило называют её dispatch(без крайней надобности идзменять её не стоит))

    function changeSlide(i) {
        setSlide(slide => slide + i);
    }

    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {slide} <br/>{autoplay.autoplay ? 'auto' : null} </div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'toggle'})}>toggle autoplay</button>
                                            <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'slow'})}>toggle autoplay</button>
                                            <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'fast'})}>toggle autoplay</button>
                </div>
            </div>
        </Container>
    )
}

function App() {
    return (
        <Slider init={false}/>		 //!!!!
    );
}
////
- если нужно передать какое-то определённое значение в наш state на этапе dispatch(например установить скорость переключения прям из инпута)--->мы можем расширить наш объект action и добавить в него новое свойство(называть его можно как угодно, но обычно его называют payload)--->в reducer ставим case 'custom'
////
function reducer(state, action){ 
    switch (action.type){
        case 'toggle' :
            return {autoplay: !state.autoplay}
        case 'slow' :
            return {autoplay: 300}
        case 'fast' :
            return {autoplay: 700}
        case 'custom':
            return {autoplay: action.payload}
        default: 
            throw new Error();
    }
}

                        <button 
                        className="btn btn-primary me-2"
                        onClick={(e) => dispatch({type: 'fast', payload: +e.target.textContent })}>1000</button>
////
- преимущества useReduce:
	1.не нужно создавать кучу ненужныхх функций, теперь они лежат в одним switch
	2.dispatch стабильна и не изменяется при воторных рендерах

КОМПОНЕНТЫ ВЫСШЕГО ПОРЯДКА:
- Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов.

Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.

const EnhancedComponent = higherOrderComponent(WrappedComponent);
Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент.

HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

В этой главе мы обсудим чем полезны компоненты высшего поряд
HOC для сквозной функциональности
Примечание

В прошлом мы рекомендовали примеси для реализации сквозной функциональности, но со временем выяснилось, что от них больше вреда, чем пользы. Узнайте, почему мы решили убрать примеси и как переписать старые компоненты.

Традиционные компоненты подразумевают многократное использование, но не позволяют с лёгкостью решить некоторые проблемы.

Рассмотрим пример CommentList, который получает список комментариев из внешнего источника данных и отображает их:

class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // "DataSource" -- произвольный глобальный источник данных
      comments: DataSource.getComments()
    };
  }

  componentDidMount() {
    // Подписаться на оповещения
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // Отписаться от оповещений
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    // Сохранить комментарии из внешнего источника в локальном состоянии
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    );
  }
}
Теперь мы решили реализовать новый компонент, который отслеживает изменения конкретной публикации и повторяет уже знакомый нам шаблон:

class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id)
    });
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}
Разница между CommentList и BlogPost в том, что они вызывают разные методы DataSource и рендерят разный вывод. Однако в большинстве своём они похожи:

Оба компонента подписываются на оповещения от DataSource при монтировании.
Оба меняют внутреннее состояние при изменении DataSource.
Оба отписываются от DataSource при размонтировании.
Можете представить, что в больших приложениях связка «подписаться на DataSource, затем вызвать setState» повторяется очень часто. Было бы здорово абстрагировать эту функциональность и использовать её в других компонентах.

Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:

const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);
Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.

Когда CommentListWithSubscription и BlogPostWithSubscription рендерятся, они передают в CommentList и BlogPost обновлённые данные DataSource через проп data:

// Эта функция принимает компонент...
function withSubscription(WrappedComponent, selectData) {
  // ...и возвращает другой компонент...
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    componentDidMount() {
      // ...который подписывается на оповещения...
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    render() {
      // ... и рендерит оборачиваемый компонент со свежими данными!
      // Обратите внимание, что мы передаём остальные пропсы
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов.

Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.

Так как withSubscription — это обычная функция, то мы можем убрать или добавить любое количество аргументов. Например, мы могли бы сделать конфигурируемым название пропа data и ещё больше изолировать HOC от оборачиваемого компонента. Также мы можем добавить аргумент для конфигурации shouldComponentUpdate или источника данных. Всё это возможно, потому что HOC полностью контролирует процесс создания компонента.

Взаимодействие между withSubscription и оборачиваемым компонентом осуществляется с помощью пропсов, так же, как и между обычными компонентами. Благодаря этому мы можем с лёгкостью заменить один HOC на другой, при условии, что они передают одни и те же пропсы в оборачиваемый компонент. Это может пригодиться если, например, мы решим поменять библиотеку получения данных.
////мой пример
import {useState, useEffect} from 'react';
import {Container} from 'react-bootstrap';

const withSlider = ({BaseComponent, getData}) => {
    return (props) => {
        const [slide, setSlide] = useState(0);
        const [autoplay, setAutoplay] = useState(false)
    
        useEffect(() => {
            setSlide(getData());
        }, [])
    
        function changeSlide(i) {
            setSlide(slide => slide + i);
        }
    return <BaseComponent 
            {...props}  //тут мы разворачиваем пропсы, которые нам приходят в этой функции и передаём их уже как пропс в BaseCompnent(объект разворачиваем в отдельный объект, который будет отдельным свойством, которое мы передаём дальше)  если передадим props={name: 'dfbdfb'} , то передастся свойство name со значением
            slide={slide} 
            autoplay={autoplay} 
            setSlide={setSlide} 
            setAutoplay={setAutoplay}
            />
    }
}

const getDataFromFirstFetch = () => {return 10};
const getDataFromSecondFetch = () => {return 20};



const SliderFirst = (props) => {
    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {props.slide}</div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(1)}>+1</button>
                </div>
            </div>
        </Container>
    )
}

const SliderSecond = (props) => {
    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {props.slide} <br/>{props.autoplay ? 'auto' : null} </div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.setAutoplay(autoplay => !props.autoplay)}>toggle autoplay</button>
                </div>
            </div>
        </Container>
    )
}   

const SliderWithFirstFetch = withSlider(SliderFirst, getDataFromFirstFetch)
const SliderWithSecondFetch = withSlider(SliderSecond, getDataFromSecondFetch)

const withLogger = WrappedComponent => (props) => {
    useEffect(() => {
        console.log('first render');
    },[])
    return <WrappedComponent {...props}/>
}

const Hello = () => {
    return(
        <h1>Hello</h1>
    )
}

const HelloWithLogger = withLogger(Hello);

function App() {
    return (
        <>
            <HelloWithLogger/>
            <SliderWithFirstFetch/>
            <SliderWithSecondFetch/>
        </>
    );
}

export default App;
////
-когда использовать HOC:
	1. подходит большому количеству компонентов
	2. если понимаете, что у вас не будет увеличиваться количество пропсов 
	3. когда нужно объединить логику
-когда не стоит использовать HOC:
	1. слишком большое количество пропсов в dispatch(в идеале только 1 пропс)
	2. если подходит только один компонент под HOC
	3. если мы каждый раз модифицируем HOC, когда подключаем новый компонент



REACT TRANSITION GROUP
- основная функция библиотеки - отслеживание состояний, появление и исчезновение элементов
- всего есть 4 компонента для работы с анимацией переходов:
	1.Transition - базовый компонент для работы с анимацией перехода, причём он разработан так, чтобы подстраиваться под платформу и не обязательно должен работать с CSS-анимацией 
	2.TransitionCSS - разработан для работы с анимациями через css через классы
	3.SwitchTransition
	4.TransitionGroup
- Transition и TransitionCSS принимают дочерний компонент и у себя устанавливают 2 базовых свойства:
	1.in - контролирует, показывается ли компонент или нет - принимает булевое значение(изменяемый компонент(как правило передаваемый в качестве пропса state)
	2.timeout - продолжительность анимации
- вышеописанный функционал позволяет отслеживать 4 стадии компонента:
	1.entering
	2.entered
	3.exiting
	4.exited
  и 6 событий:	
	1.onEnter
	2.onEntering
	3.onEnter
	4.onExit
	5.onExiting
	6.onExited
- display невозможно анимировать 
- import { CSSTransition } from 'react-transition-group';
- каждый раз, когда у нас изменяется state, вызывается children - функция внутри <Transition>
- мы можем не только показывать при помощи стилей наши элементы(скрывать, показывать и т.д.), но и можем контролировать их рендеринг. К примеру я хочу сказать: пока моя модель не открыта, его не будет существовать в DOM-дереве или наоборот, когда моё модальное окно закрывается, я хочу чтобы оно полностью исчезала из DOM-дерева--->для этого существует 2 пропа:
	1.mountOnEnter
	2.unmountOnExit
////
<Transition timeout={duration} in={props.show} unmountOnExit>
            {state => (
                <div className="modal mt-5 d-block" style={{
                    ...defaultStyle,
                    ...transitionStyles[state]  //зависит от state(библиотека сама отслеживает, на каком состоянии компонент находится и передаёт это в виде стэйта(в свою очередь таких состояний 4--->в итоге мы получаем от transitionsStyle 1 свойство))
                  }}>
////
- также есть методы, кот. можем использовать:
	1.onEnter
	2.onEntering
	3.onEnter			
	4.onExit
	5.onExiting
	6.onExited
	Классичечский случай - 
////
const Modal = (props) => {

    const duration = 300;

    const defaultStyle = {          //стили по умолчанию
        transition: `${duration}ms ease-in-out`,
        opacity: 0,
        visibility: 'hidden'
    }

    const transitionStyles = {  //отвечают за проммежуточное состояние
        entering: { opacity: 1, visibility: 'visible'},
        entered: { opacity: 1, visibility: 'visible'},
        exiting: { opacity: 0, visibility: 'hidden'},
        exited: { opacity: 0, visibility: 'hidden'}
    }

    return (
        <Transition 
        timeout={duration} 
        in={props.show} 
        unmountOnExit 
        onEnter={()=>props.setShowTrigger(false)} 
        onExit={()=>props.setShowTrigger(true)}>
            {state => (
                <div className="modal mt-5 d-block" style={{
                    ...defaultStyle,
                    ...transitionStyles[state]  //зависит от state(библиотека сама отслеживает, на каком состоянии компонент находится и передаёт это в виде стэйта(в свою очередь таких состояний 4--->в итоге мы получаем от transitionsStyle 1 свойство))
                  }}>
                <div className="modal-dialog">
                    <div className="modal-content">
                    <div className="modal-header">
                        <h5 className="modal-title">Typical modal window</h5>
                        <button onClick={() => props.onClose(false)} type="button" className="btn-close" aria-label="Close"></button>
                    </div>
                    <div className="modal-body">
                        <p>Modal body content</p>
                    </div>
                    <div className="modal-footer">
                        <button onClick={() => props.onClose(false)} type="button" className="btn btn-secondary">Close</button>
                        <button onClick={() => props.onClose(false)} type="button" className="btn btn-primary">Save changes</button>
                    </div>
                    </div>
                </div>
            </div>
            )}
        </Transition>
    )
}

function App() {
    const [showModal, setShowModal] = useState(false);
    const [showTrigger, setShowTrigger] = useState(true)

    return (
        <Container>
            <Modal show={showModal} onClose={setShowModal} setShowTrigger={setShowTrigger}/>
            {showTrigger ? 
            <button 
                type="button" 
                className="btn btn-warning mt-5"
                onClick={() => setShowModal(true)}>Open Modal</button>:
            null}
        </Container>
    );
}
////
- скрываем кнопку, когда нажимаем и показывается модальное окно:
////
        <Transition 
        timeout={duration} 
        in={props.show} 
        unmountOnExit 
        onEnter={()=>props.setShowTrigger(false)} 	//!!!
        onExit={()=>props.setShowTrigger(true)}>	//!!!
            {state => (
                <div className="modal mt-5 d-block" style={{
                    ...defaultStyle,
                    ...transitionStyles[state]  //зависит от state(библиотека сама отслеживает, на каком состоянии компонент находится и передаёт это в виде стэйта(в свою очередь таких состояний 4--->в итоге мы получаем от transitionsStyle 1 свойство))
                  }}>
                <div className="modal-dialog">
                    <div className="modal-content">
			....
function App() {
    const [showModal, setShowModal] = useState(false);
    const [showTrigger, setShowTrigger] = useState(true)

    return (
        <Container>
            <Modal show={showModal} onClose={setShowModal} setShowTrigger={setShowTrigger}/>
            {showTrigger ? 
            <button 
                type="button" 
                className="btn btn-warning mt-5"
                onClick={() => setShowModal(true)}>Open Modal</button>:
            null}
        </Container>
    );
}
////
- но с инлайн стилями немножко неудобно порой работать(такие как мы использовали в defaultStyles), поэтому рассмотрим CSSTransition:
- вместо инлайн-стилей мы будем использовать css-классы
CSSTransition applies a pair of class names during the appear, enter, and exit states of the transition. The first class is applied and then a second *-active class in order to activate the CSS transition. After the transition, matching *-done class names are applied to persist the transition state.

function App() {
  const [inProp, setInProp] = useState(false);
  const nodeRef = useRef(null);
  return (
    <div>
      <CSSTransition nodeRef={nodeRef} in={inProp} timeout={200} classNames="my-node">
        <div ref={nodeRef}>
          {"I'll receive my-node-* classes"}
        </div>
      </CSSTransition>
      <button type="button" onClick={() => setInProp(true)}>
        Click to Enter
      </button>
    </div>
  );
}
When the in prop is set to true, the child component will first receive the class example-enter, then the example-enter-active will be added in the next tick. CSSTransition forces a reflow between before adding the example-enter-active. This is an important trick because it allows us to transition between example-enter and example-enter-active even though they were added immediately one after another. Most notably, this is what makes it possible for us to animate appearance.

.my-node-enter {
  opacity: 0;
}
.my-node-enter-active {
  opacity: 1;
  transition: opacity 200ms;
}
.my-node-exit {
  opacity: 1;
}
.my-node-exit-active {
  opacity: 0;
  transition: opacity 200ms;
}
*-active classes represent which styles you want to animate to, so it's important to add transition declaration only to them, otherwise transitions might not behave as intended! This might not be obvious when the transitions are symmetrical, i.e. when *-enter-active is the same as *-exit, like in the example above (minus transition), but it becomes apparent in more complex transitions.

Note: If you're using the appear prop, make sure to define styles for .appear-* classes as well.

classNames
The animation classNames applied to the component as it appears, enters, exits or has finished the transition. A single name can be provided, which will be suffixed for each stage, e.g. classNames="fade" applies:

fade-appear, fade-appear-active, fade-appear-done
fade-enter, fade-enter-active, fade-enter-done
fade-exit, fade-exit-active, fade-exit-done
//// App.css
.modal{                     /* те стили, которые будут после завершения анимации, если мы не укажем modal0-exit-done */
opacity: 0;
visibility: hidden;
transition: all opacity 900ms;        /* или можно указать unmountOnExit и unmountOnEnter и тогда нам не нужен этот класс */
}
.modal-enter {
  opacity: 0;
}
.modal-enter-active {
  opacity: 1;
  visibility: visible;
  transition: all opacity 2000ms;
}
.modal-enter-done { /* нужно заполнять этот класс */
  opacity: 1;
  visibility: visible;
}
.modal-exit {
  opacity: 1;
}
.modal-exit-active {
  opacity: 0;
  visibility: hidden;
  transition: all opacity 300ms;
}
////App.js
const Modal = (props) => {

    const duration = 300;

    return (
        <CSSTransition 
        timeout={duration} 
        in={props.show} 
        onEnter={()=>props.setShowTrigger(false)} 
        onExit={()=>props.setShowTrigger(true)}
        classNames="modal">
                <div className="modal mt-5 d-block">
                <div className="modal-dialog">
                    <div className="modal-content">
                    <div className="modal-header">
                        <h5 className="modal-title">Typical modal window</h5>
                        <button onClick={() => props.onClose(false)} 
////
- в CSSTransition есть такие же проперти, как и в Transition--->это значит, что мы можем применить, к примеру, unmountOnExit
- SwitchTransition и TransitionGroup позволяют модифицировать поведение базовых двух вышеописанных компонентов
- SwitchTransition оборачивает один из базовых компонентов(Transition,CSSTransition) и устанавливает режим рендеринга c помощью пропа mode
Props
mode
Transition modes. out-in: Current element transitions out first, then when complete, the new element transitions in. in-out: New element transitions in first, then when complete, the current element transitions out.

type: 'out-in'|'in-out'
default: 'out-in'
children
Any Transition or CSSTransition component.

type: element
- TransitionGroup выступает обёрткой, но оборачивает большое количество базовых компонентов. При использовании TransitionGroup в базовые компоненты не передаётся проп in, так как именно TransitionGroup отвечает за отслеживание, появление и исчезновение компонентов и применения анимации к ним, причём он говорит запустить анимацию, а вот сам вид анимации определяет базовый компонент
- TransitionGroup следит за теми элементами, которые ест внутри него и, если произойдёт какое-то действие, которое приведёт к удалению или созданию базового компонента, то TransitionGroup воспроизвдёт анимацию(но сама анимация должна быть прописана в самом базовом компоненте)
- у TransitionGroup обязательно нужно указывать атрибут component - это обёртка, которую он будет рендерить(по умолчанию рендерит div)
////
    function renderItems(arr) {
        const items =  arr.map((item, i) => {
            let imgStyle = {'objectFit' : 'cover'};
            if (item.thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
                imgStyle = {'objectFit' : 'unset'};
            }
            
            return (
                <CSSTransition key={item.id} timeout={500} classNames="char__item">
                    <>
                    <li 
                        className="char__item"
                        tabIndex={0}
                        ref={el => itemRefs.current[i] = el}
                        onClick={() => {
                            props.onCharSelected(item.id);
                            focusOnItem(i);
                        }}
                        onKeyPress={(e) => {
                            if (e.key === ' ' || e.key === "Enter") {
                                props.onCharSelected(item.id);
                                focusOnItem(i);
                            }
                        }}>
                            <img src={item.thumbnail} alt={item.name} style={imgStyle}/>
                            <div className="char__name">{item.name}</div>
                    </li></>
                </CSSTransition>
            )
        });
        // А эта конструкция вынесена для центровки спиннера/ошибки
        return (
            <ul className="char__grid">
                <TransitionGroup component={null}>
                    {items}
                </TransitionGroup>
            </ul>
        )
    }
////

-анимации при помощи самих скриптов нужны очень редко(всё дело в сложности их разработки).Одной из самых популярных библиотек для их создания является ReactMotion


Formik,Yup и работа с формами любой сложности:
-Redux Form - вторая по популярности библиотека, в новых проектах использовать её не рекомендуется(проблема этой библиотеки в том, что данные в каждой форме хранятся в хранилище и это нее всегда оправданно, так как данных всегда много , ещё и в каждую форму её засовывать+при введении данных в форму каждый раз будет обновляться хранилище, поэтому для маленьких приложений это в принципе не было проблемой, а вот для больших приложений это уже накладка по оптимизации) - это уже слишком--->эта библиотека заменена на React Final Form--->если вы хотите использовать эту библиотекку, то нужно использовать React Final Form(тут смысл и подход в целом очень похож на Formik
- также можно создать свой готовый хук по работе с формами 
- React Hook Form - готовый хук, который оформлен в отдельную библиотеку - очень крутая библиотека
- все эти варианты применимы в проектах, а отталкиваться вы должны от требований, от стиля проекта или от того,с чем вам удобнее использовать. Есть ещё варианты библиотек, но лучше не распыляться, а выучить несколько удобных инструментов
- в формах name - это очень и очень важно(с ним важно правильно работать - не забывать его устанавливать и связывать)
- FORMIK : самый главный компонент - Formik - его компоненты:
	1.initialValues - наши первичные значения, с которыми наша форма будет появляться на странице (передаётся в виде объекта) - эта связь с формой идёт по атрибуту name(в некоторых случаях по id, но в большинстве случаев лучше ориентироваться по name)
	2.validate - будем передавать функцию по валидации каждого интерактивного элемента - эта функция принимает аргумент values(значения, которые у нас есть в форме - по факту что-то типо объекта, который содержит ключ-значение). Сначала мы создаём объект ошибок , потому что мы будем смотреть, какие будут возникать ошибки в процессе валидации
	3. onSubmit - это проперти, который принимает функцию - тут мы будем делать самое главное действие, то есть отправку наших данных куда-то(возможно здесь не всегда будет отправка, но самое главное, что в этой функции мы будем подстверждать свою форму. Здесь может происходить всё, что угодно, например, формирование формата json (это то, что будет происходит при нажатии на кнопку enter или просто на button)
- во внутрь компонента мы передаём функцию(в неё передаём тот объект, который будет приходить в нашу форму)
////
{
         values,
         errors,
         touched,
         handleChange,
         handleBlur,
         handleSubmit,
         isSubmitting,
         /* and other goodies */
       }
////
- в библиотеку введены несколько готовых компонентов, которые мы можем использовать - Form, Field, ErrorMessage. Это уже готовые компоненты, которые мы через контекст можем использовать (на самом деле контекст тут уже встроен, нам не нужно ничего настраивать):
////
 import React from 'react';
 import { Formik, Form, Field, ErrorMessage } from 'formik';
 
 const Basic = () => (
   <div>
     <h1>Any place in your app!</h1>
     <Formik
       initialValues={{ email: '', password: '' }}
       validate={values => {
         const errors = {};
         if (!values.email) {
           errors.email = 'Required';
         } else if (
           !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
         ) {
           errors.email = 'Invalid email address';
         }
         return errors;
       }}
       onSubmit={(values, { setSubmitting }) => {
         setTimeout(() => {
           alert(JSON.stringify(values, null, 2));
           setSubmitting(false);
         }, 400);
       }}
     >
       {({ isSubmitting }) => (
         <Form>
           <Field type="email" name="email" />
           <ErrorMessage name="email" component="div" />
           <Field type="password" name="password" />
           <ErrorMessage name="password" component="div" />
           <button type="submit" disabled={isSubmitting}>
             Submit
           </button>
         </Form>
       )}
     </Formik>
   </div>
 );
 
 export default Basic;
////
- дополнительный инструменатрий, который советует использовать Formik - библиотека по валидации( её можно прописывать самостоятельно. Но если у нас однотипные задачии это не прям сверх что-то сложное, то сюда можно подключить какую-то стороннюю библиотеку, чтобы облегчить работу - YUP - именно такая библиотека)
-Formik можно использовать не только в форме компонента--->можно использовать хук - useFormik, который занимается тем же. Компонент подходит больше, если мы используем его в реальных приложениях за счёт того, что мы пробрасываем контекст и пробрасывать события будет куда удобнее	
- сначала изучим хук useFormik:
////
const Form = () => {

    const formik = useFormik({
        initialValues: {
            name: '',
            email: '',
            amount: 0,
            currency: '',
            text: '',
            terms: false
        },
        onSubmit: values => console.log(JSON.stringify(values, null, 2)) // данная конструкция превращает поступивший объект(values) в строку в нормальном формате . Если мы попробуем объект превратить в строку, то получим Object object
    //   console.log(JSON.stringify({ x: 5, y: 6 }));
    // expected output: "{"x":5,"y":6}"
    //
    //console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
    // expected output: "[3,"false",false]"
    
    //console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
    // expected output: "{"x":[10,null,null,null]}"
    
    //console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
    // expected output: ""2006-01-02T15:04:05.000Z""
    
    })

    return (
        <form className="form" onSubmit={formik.handleSubmit}>
            <h2>Отправить пожертвование</h2>
            <label htmlFor="name">Ваше имя</label>
            <input
                id="name"
                name="name"
                type="text"
                value={formik.values.name}
                onChange={formik.handleChange}//теперь, когда мы будем что-то печатать в этот input, у нас будет вызываться функция handleChange(которая встроена в formik) и будет смотреть, какой инпут у нас изменяется. Потом у нас идёт обратная связь и это значение будет попадать обратно в value. Поэтому handleChange настроен у нас так, чтобы изменять и state и значение инпута
            />
            <label htmlFor="email">Ваша почта</label>
            <input
                id="email"
                name="email"
                type="email"
                value={formik.values.email}
                onChange={formik.handleChange}
            />
            <label htmlFor="amount">Количество</label>
            <input
                id="amount"
                name="amount"
                type="number"
                value={formik.values.amount}
                onChange={formik.handleChange}
            />
            <label htmlFor="currency">Валюта</label>
            <select
                id="currency"
                name="currency"
                value={formik.values.currency}
                onChange={formik.handleChange}>
                    <option value="">Выберите валюту</option>
                    <option value="USD">USD</option>
                    <option value="UAH">UAH</option>
                    <option value="RUB">RUB</option>
            </select>
            <label htmlFor="text">Ваше сообщение</label>
            <textarea 
                id="text"
                name="text"
                value={formik.values.text}
                onChange={formik.handleChange}
            />
            <label className="checkbox">
                <input 
                name="terms" 
                type="checkbox"
                value={formik.values.terms}
                onChange={formik.handleChange} />
                Соглашаетесь с политикой конфиденциальности?
            </label>
            <button type="submit">Отправить</button>
        </form>
    )
}

export default Form;
////
- нам нужна валидация. В HTML5 есть возможности для валидации, встренные в браузер, такие как паттерн-атрибут, required, minlength и прочее, но чаще всего нам нужна собственная валидация - причина: в разных браузерах по разному отображаются разные виды встроенных валидаций, а нам необходимо сделать так, чтобы везде они выглядели одинаково+не везде есть такая валидация(ReactNative - здесь разрабатываются формы, которые на мобильных устройствах без браузеров)
- чтобы валидация не срабатывала одновременно на все элементы формы, используется объект, который отслеживает, использовал ли пользователь элемент - touched - по форме он выглядит также, как и наш объект errors - содержит ключи с именами
////
const validate = values => {							//!!
    const errors = {};

    if(!values.name){
        errors.name = 'Обязательное поле!'
    }else if(values.name.length < 2){
        errors.name = 'Минимум 2 символа для заполнения!'
    }

    if(!values.email){
        errors.email = 'Обязательное поле!'
    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)){
        errors.email = 'Неправильный email адрес'
    }

    return errors;
}
const Form = () => {

    const formik = useFormik({
        initialValues: {
            name: '',
            email: '',
            amount: 0,
            currency: '',
            text: '',
            terms: false
        },
        validate, 														//!!
        onSubmit: values => console.log(JSON.stringify(values, null, 2))
    })

    return (
        <form className="form" onSubmit={formik.handleSubmit}>
            <h2>Отправить пожертвование</h2>
            <label htmlFor="name">Ваше имя</label>
            <input
                id="name"
                name="name"
                type="text"
                value={formik.values.name}
                onChange={formik.handleChange}
            />
            {formik.errors.name ? <div>{formik.errors.name}</div>: null}							//!!прокидываем оишбку
            <label htmlFor="email">Ваша почта</label>
            <input
                id="email"
                name="email"
                type="email"
                value={formik.values.email}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur} //срабатывает, когда фокус уходит с элемента		//!!
            />
            {formik.errors.email && formik.touched.email ? <div>{formik.errors.email}</div>: null}		//!!
            <label htmlFor="amount">Количество</label>
            <input
                id="amount"
                name="amount"
                type="number"
                value={formik.values.amount}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur}												//!!
            />
            <label htmlFor="currency">Валюта</label>
            <select
                id="currency"
                name="currency"
                value={formik.values.currency}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur}												//!!
                >
                    
                    <option value="">Выберите валюту</option>
                    <option value="USD">USD</option>
                    <option value="UAH">UAH</option>
                    <option value="RUB">RUB</option>
            </select>
            <label htmlFor="text">Ваше сообщение</label>
            <textarea 
                id="text"
                name="text"
                value={formik.values.text}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur}
////
- ноиспользовать так много когда+регулярные выражения не всегда хочется--->для таких целей были придуманф библиотеки по типу Yup - на самом деле это набор команд, которые под капотом делают тоже самое, что мы и прописывали:
-Yup.object() - команда, которая говорит, что мы вернём объект с какими-то ключами и у этих ключей как раз-таки будут набор правил:
////
import * as Yup from 'yup'

const Form = () => {

    const formik = useFormik({
        initialValues: {
            name: '',
            email: '',
            amount: 0,
            currency: '',
            text: '',
            terms: false
        },
        validationSchema: Yup.object({
            name: Yup.string()
                .min(2, 'Минимум 2 символа!')
                .required('Обязательное поле!'),
            email: Yup.string()
                    .email('Неправильный email адрес')
                    .required('Обязательное поле!')
            amount: Yup.number()
                        .required('Обязательное поле!'),
            currency: Yup.string()
                        .required('Выберите валюту!'),
            text: Yup.string()
                    .min(10, 'Не менее 10 символов'),
            terms: Yup.boolean()
                    .required('Необходимое согласие!')
                    .oneOf([true], 'Необходимое согласие!')/* тут будут значения, которые будут проходить валидацию. нам необходимо сказать, что если у нас будет true, то мы будем пропускать проверку, а если нет, то будем выдавать ошибку*/
        }) ,
        onSubmit: values => console.log(JSON.stringify(values, null, 2)) 
    })

    return (
        <form className="form" onSubmit={formik.handleSubmit}>
            <h2>Отправить пожертвование</h2>
            <label htmlFor="name">Ваше имя</label>
            <input
                id="name"
                name="name"
                type="text"
                value={formik.values.name}
                onChange={formik.handleChange}
            />
            {formik.errors.name ? <div>{formik.errors.name}</div>: null} 
            <label htmlFor="email">Ваша почта</label>
            <input
                id="email"
                name="email"
                type="email"
                value={formik.values.email}
                onChange={formik.handleChange}
                onBlur={formik.handleBlur} //срабатывает, когда фокус уходит с элемента
            />
            {formik.errors.email && formik.touched.email ? <div>{formik.errors.email}</div>: null}  // Yup точно также как и в случае ручной валидации передаёт объект ошибки
////
- getFieldProps - позволяет получать определённые пропы, когда мы используем хук
////
            <input
                id="amount"
                name="amount"
                type="number"
                {...Formik.getFieldProps('name')} вместо всех трёх пропов, что были выше
            />
/////
- в самом начале мы показывали, что в самом формике уже есть готовые компоненты, которые через контекст будут принимать пропсы. Именно для этого нам нужно переписать всё на классическую форму без хука. Именно поэтому базовый компонент Formik будет чаще применяться по сравнению с useFormik за счт чуть больших возможностей. Если разбираться как работает библиотека внутри, то на самом деле хук useFormik используется внутри Formik, а потом это всё уже организовывается в контекст.
- isSubmitting - это состояние, которое говорит, что на данный момент наша форма сабмитится---> мы используем атрибут disabled={isSubmitting} на кнопке и не можем повторно отправить нашу форму
////
       {({ isSubmitting }) => (						// если нам не нужны эти сущности, которые приходят из формика, то мы можем не использовать render-prop(то есть 
         <Form>									// не вызывать функцию, а просто отрендерить форму без функции
           <Field type="email" name="email" />
           <ErrorMessage name="email" component="div" />
           <Field type="password" name="password" />
           <ErrorMessage name="password" component="div" />
           <button type="submit" disabled={isSubmitting}>
             Submit
           </button>
         </Form>
       )}
////
- вот что получилось в итоге:
////
const CustomForm = () => {
  return (
    <Formik
      initialValues={{
        name: "",
        email: "",
        amount: 0,
        currency: "",
        text: "",
        terms: false,
      }}
      validationSchema={Yup.object({
        name: Yup.string()
          .min(2, "Минимум 2 символа!")
          .required("Обязательное поле!"),
        email: Yup.string()
          .email("Неправильный email адрес")
          .required("Обязательное поле!"),
        amount: Yup.number().required("Обязательное поле!"),
        currency: Yup.string().required("Выберите валюту!"),
        text: Yup.string().min(10, "Не менее 10 символов"),
        terms: Yup.boolean()
          .required("Необходимое согласие!")
          .oneOf([true], "Необходимое согласие!"),
      })}
      onSubmit={(values) => console.log(JSON.stringify(values, null, 2))}
    >
      <Form className="form">
        <h2>Отправить пожертвование</h2>
        <label htmlFor="name">Ваше имя</label>
        <Field
          id="name"
          name="name"
          type="text" //другие пропы не нужны, так как он получает их автоматически. formik смотрит на name, потом на initialValues и потом сам подставляет значение
        />
        <ErrorMessage
          className="error"
          name="name" /* связываем ошибку с полем */
          componenet="div" /* если не указать, будет обычная строка */
        />
        <label htmlFor="email">Ваша почта</label>
        <Field id="email" name="email" type="email" />
        <ErrorMessage
          className="error"
          name="email" /* связываем ошибку с полем */
          componenet="div" /* если не указать, будет обычная строка */
        />
        <label htmlFor="amount">Количество</label>
        <Field id="amount" name="amount" type="number" />
        <ErrorMessage
          className="error"
          name="amount" /* связываем ошибку с полем */
          componenet="div" /* если не указать, будет обычная строка */
        />
        <label htmlFor="currency">Валюта</label>
        <Field id="currency" name="currency" as="select">
          <option value="">Выберите валюту</option>
          <option value="USD">USD</option>
          <option value="UAH">UAH</option>
          <option value="RUB">RUB</option>
        </Field>
        <ErrorMessage
          className="error"
          name="currency" /* связываем ошибку с полем */
          componenet="div" /* если не указать, будет обычная строка */
        />
        <label htmlFor="text">Ваше сообщение</label>
        <Field id="text" name="text" as="textarea" /* то,что хотим создать */ />
        <ErrorMessage
          className="error"
          name="textarea" /* связываем ошибку с полем */
          componenet="div" /* если не указать, будет обычная строка */
        />
        <label className="checkbox">
          <Field name="terms" type="checkbox" /* для него as не нужен */ />
          <ErrorMessage
            className="error"
            name="checkbox" /* связываем ошибку с полем */
            componenet="div" /* если не указать, будет обычная строка */
          />
          Соглашаетесь с политикой конфиденциальности?
        </label>
        <button type="submit">Отправить</button>
      </Form>
    </Formik>
  );
};
////
- но у нас есть повторяющиеся элементы с одними и теми же атрибутами---> оптимизируем этот момент:
////
const MyTextInput = ({ label, ...props }) => {
  const [field, meta] =
    useField(
      props
    ); /* useField позволяет получать массив из 2 объектов. field - это пропсы, которые мы будем передавать в input(все эти значения будут получаться через контекст), meta - метаданные с ошибками и был ли уже использован этот инпут */
  return (
    <>
      <label htmlFor={props.name}>{label}</label>
      <input {...props} {...field} />
      {meta.touched && meta.error ? (
        <div className="error">{meta.erro}r</div>
      ) : null}
    </>
  );
};

SEO-ОПТИМИЗАЦИЯ:
- Поиско́вая оптимиза́ция — комплекс мероприятий по внутренней и внешней оптимизации для поднятия позиций сайта в результатах выдачи поисковых систем по определённым запросам пользователей, с целью увеличения сетевого трафика и потенциальных клиентов и последующей монетизации этого трафика.
- чем больше условий соблюдены, тем выше позиция в поиске. За оценку SEO отвечает поисковый робот
- со стороны контента, ключевых слов и ссылок уже занимаются другие люди(в том числе и SEO-оптимизаторы)
- основные технические критерии - скорость загрузки сайта, использование семантической вёрстки и правильное применение тегов
- часть веб-приложений не нуждается в SEO - всё зависит от его предназначения(если это контентное приложение по типу новостного портала, то тут SEO обязательно, потому что есть ключевые сдова, люди ищут это в поиске и попадают на сайт. То же самое с интернет-магазинами, с блогами. А вот инструмент, который просто работает в браузере, например, Figma - само приложение внутри - сложновато и не очень нужно оптимизировать, поэтому в работе будет всё упираться в задачу). Иногда делают гибриды, когда у приложения есть страница с контентом и есть самоп приложение и всё это хранится на одном сервере и домене
- весь контенет в веб-приложении генерируется через JS-код--->это значит, что сама страничка(html) у нас будет пустая. Более того все так называемые страницы генерирует также реакт(мы остаёмся всё на той же странице, но уже с другим сгенерированным контентом)--->если поисковый робот придёт к нам на сервер, то по запросу главной страницы он получит пустой index.html и ссылок на другие страницы он тоже не увидит, это значит,что о других страницах он тоже ничего не узнает--->никакой контент он вообще не увидит в вашем приложении.
- на момент записи урока поисковые робота не умеют проходить через JS-код при обходе таких страниц, но потихоньку учатся(пишут, что гугловский бот уже умеет это делать, но ещё не очень хорошо) и вот это главная задача, которая решается разными путями--->
1.один из них - рендеринг приложения на стороне сервера, когда поисковому роботу будет отдаваться уже готовая страница(server side rendering - с реактом чаще всего применяется framework - next.js)
2.пререндеринг - когда создаём production build-приложение,то дополнительно сохраняем html-копии каждой страницы, которая есть у вас в приложении . Делается это с помощью спец. библиотек и там чаще всего используется так называемый headless browser(можете представить, что это браузер без визуальной оболочки - эьти библиотеки будут создавать копию каждой вашей странчики) - react-snap

- у сайта на каждая страничка должна быть с разными тайтлами и метатегами. У нас до этого момента был только 1 title и 1 метатег на все страницы --->React-helmet - библиотека, которая работает как в обычном виде(на фронте), так и на стороне сервера(server side rendering) - её функционал позволяет вам динамически изменять 9 параметров на данный момент:
base
bodyAttributes
htmlAttributes
link
meta
noscript
script - можем динамически добавлять в head скрипты(может понадобиться для чего угодно)
style - можем динамически добавлять в head стили(может понадобиться для чего угодно)
title
////
import { Link } from "react-router-dom";
import { Helmet } from "react-helmet";

import "./singleComicLayout.scss";

const SingleComicLayout = ({ data }) => {
  const { title, description, pageCount, thumbnail, language, price } = data;

  return (
    <div className="single-comic">
      <Helmet>
        <meta name="description" content={`${title} comics book`} />
        <title>{title}</title>
      </Helmet>
      <img src={thumbnail} alt={title} className="single-comic__img" />
      <div className="single-comic__info">
        <h2 className="single-comic__name">{title}</h2>
        <p className="single-comic__descr">{description}</p>
        <p className="single-comic__descr">{pageCount}</p>
        <p className="single-comic__descr">Language: {language}</p>
        <div className="single-comic__price">{price}</div>
      </div>
      <Link to="/comics" className="single-comic__back">
        Back to all
      </Link>
    </div>
  );
};

export default SingleComicLayout;
////


ПРИНЦИП КОНЕЧНЫХ АВТОМАТОВ:
- концепция конечного автомата - это такая сущность, которая имеет определённое количество состояний. Это математическая модель, которая применяется во многих областях программирования(в ИИ, играх)
- Finite-State Machine(FSM) - конечный автомат по английски
- если придираться, то любое приложение или участок кода, который использует приложение и меняет его. Другое дело, что мы используем лишь часть концепции - состояние у нас есть, но в ручную мы что-то делаем, нам же нужно немного оптимизировать процесс, чтобы это всё происходило автоматически. Ранее мы использоваки хук useReducer, когда состояние мы могли менять разными путями, используя только одну функцию dispatch(мы передавали в dispatch какой-то экшн и в зависимости от этого параметра мы выполняли какое-то определённое действие внутри функции reducer) - вот это уже ближе к концепции машин-состояния, так как существует конечное количество состояний, которые мы переключаем оптимизированно всего через 1 функцию и это довольно удобно(redux будет построен на таком же прицнипе,так что не забывайте про этот код) про него 
- FSM могут реальзовываться по-разному и подход к нему тоже может быть разным - это концепция, а не какая-то определённая техника, главное, чтобы соблюдались базовые принципы - конечное количество состояний, механизм перехода, удобный функционал отображения и только 1 активное состояние 
- общее соглашение - состояния, прописываемые в конечных автоматах необходимо прописывать строками, а не булевыми значениями. Это связано с бэкэндом, в  том числе и с расширением количества состяний, ведь строки можно спокойно добавлять

- используем концепцию на нашем проекте(при помощи process). У нас будет частный случай FSM
////http.hook.js

export const useHttp = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [process, setProcess] =
    useState("waiting"); /* текущий процесс - текущее состояние компонента */

  const request = useCallback(
    async (
      url,
      method = "GET",
      body = null,
      headers = { "Content-Type": "application/json" }
    ) => {
      setLoading(true);

      setProcess("loading");
      try {
        const response = await fetch(url, { method, body, headers }); //этот хук будет только отправлять запрос, но не будет обрабатывать его при помощи .then, .catch

        if (!response.ok) {
          throw new Error(`Could not fetch ${url}, status: ${response.status}`);
        }

        const data = await response.json();

        setLoading(false);

        return data;
      } catch (e) {
        setLoading(false);
        setError(e.message);
        setProcess("error");
        throw e;
      }
    },
    []
  ); // мы предполагаем, чтобы эту функцию будем помешать внутрь другого компонента, поэтому, чтобы не совершать лишних запросов, будем использовать мемоизироанную версию

  const clearError = useCallback(() => {
    setError(null);
    setProcess("loading");
  }, []);

  return { loading, request, error, clearError, process, setProcess };
};
////
////MarvelService.js
const useMarvelService = () => {
  const { loading, request, error, clearError, process, setProcess } =		//отписал только изменения
    useHttp();
...
...
...
return {
    loading,
    error,
    process,
    setProcess,
    getAllCharacters,
    getCharacter,
    getCharacterByName,
    clearError,
    getAllComics,
    getComic,
  };
};
////
////charInfo.js
const CharInfo = (props) => {
  const [char, setChar] = useState(null);

  const { loading, error, getCharacter, clearError, process, setProcess } =
    useMarvelService();

  useEffect(() => {
    updateChar();
  }, [props.charId]);

  const updateChar = () => {
    const { charId } = props;
    if (!charId) {
      return;
    }

    clearError();
    getCharacter(charId)
      .then(onCharLoaded)
      .then(() =>
        setProcess("confirmed")
      ); /* изменяем process на confirmed именно тут, потому что у нас в http.hook.js и useMarvelService операции асинхронные и если бы мы ставили confirmed уже в hhtp-хуке, то у нас не успевал бы загрузиться наш компонент, так как на тот момент он проходил бы стадию _transformCharacter в ueMarvelservice, поэтому ставим confirmed только по завершении загрузке именно в этом месте   */
  };

  const onCharLoaded = (char) => {
    setChar(char);
  };

  const setContent = (process, char) => {			//а раньше здесь у нас были сложные логические условия
    switch (process) {
      case "waiting":
        return <Skeleton />;
        break;
      case "loading":
        return <Spinner />;
        break;
      case "confirmed":
        return <View char={char} />;
        break;
      case "error":
        return <ErrorMessage />;
        break;
    }
  };

  return <div className="char__info">{setContent(process, char)}</div>;
};
////теперь у нас нет условий со сложной логикой отображения, теперь нам не нужны такие переменные как error и loading, так как за всё отвечает только одна переменная, которая у нас отображает процесс нашего компонента(его состояние мы теперь храним в качестве строки и это прекрасно работает
- теперь немного преобразуем наш код:
////вынесем отдельно функцию setContent.js
import Spinner from "../components/spinner/Spinner";
import ErrorMessage from "../components/errorMessage/ErrorMessage";
import Skeleton from "../components/skeleton/Skeleton";

const setContent = (process, Component, data) => {
  switch (process) {
    case "waiting":
      return <Skeleton />;
      break;
    case "loading":
      return <Spinner />;
      break;
    case "confirmed":
      return <Component data={data} />;
      break;
    case "error":
      return <ErrorMessage />;
      break;
  }
};

export default setContent;
////
////http.hook.js
import React from "react";
import { useState, useCallback } from "react";

export const useHttp = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [process, setProcess] =
    useState("waiting"); /* текущий процесс - текущее состояние компонента */

  const request = useCallback(
    async (
      url,
      method = "GET",
      body = null,
      headers = { "Content-Type": "application/json" }
    ) => {
      setLoading(true);

      setProcess("loading");
      try {
        const response = await fetch(url, { method, body, headers }); //этот хук будет только отправлять запрос, но не будет обрабатывать его при помощи .then, .catch

        if (!response.ok) {
          throw new Error(`Could not fetch ${url}, status: ${response.status}`);
        }

        const data = await response.json();

        setLoading(false);

        return data;
      } catch (e) {
        setLoading(false);
        setError(e.message);
        setProcess("error");
        throw e;
      }
    },
    []
  ); // мы предполагаем, чтобы эту функцию будем помешать внутрь другого компонента, поэтому, чтобы не совершать лишних запросов, будем использовать мемоизироанную версию

  const clearError = useCallback(() => {
    setError(null);
    setProcess("loading");
  }, []);

  return { loading, request, error, clearError, process, setProcess };
};
////CharInfo.js
import { useState, useEffect } from "react";
import PropTypes from "prop-types";

import useMarvelService from "../../services/MarvelService";
import setContent from "../../utils/SetContent";
import "./charInfo.scss";

const CharInfo = (props) => {
  const [char, setChar] = useState(null);

  const { getCharacter, clearError, process, setProcess } =
    /* теперь после использования концепции автоматов нам не нужны loading и error */
    useMarvelService();

  useEffect(() => {
    updateChar();
  }, [props.charId]);

  const updateChar = () => {
    const { charId } = props;
    if (!charId) {
      return;
    }

    clearError();
    getCharacter(charId)
      .then(onCharLoaded)
      .then(() =>
        setProcess("confirmed")
      ); /* изменяем process на confirmed именно тут, потому что у нас в http.hook.js и useMarvelService операции асинхронные и если бы мы ставили confirmed уже в hhtp-хуке, то у нас не успевал бы загрузиться наш компонент, так как на тот момент он проходил бы стадию _transformCharacter в ueMarvelservice, поэтому ставим confirmed только по завершении загрузке именно в этом месте   */
  };

  const onCharLoaded = (char) => {
    setChar(char);
  };

  return <div className="char__info">{setContent(process, View, char)}</div>;
};
////ChatList немного отличается по функционалу(из-за NewItemLoading), поэтому немного модифицируем SetContent
import { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import useMarvelService from "../../services/MarvelService";
import "./comicsList.scss";
import Spinner from "../spinner/Spinner";
import ErrorMessage from "../errorMessage/ErrorMessage";

const setContent = (process, Component, newItemLoading) => {
  switch (process) {
    case "waiting":
      return <Spinner />;
      break;
    case "loading":
      return newItemLoading ? (
        <Component />
      ) : (
        <Spinner />
      ); /* создали отдельную функцию, потому что наш компонент работает немножко иначе из-за наличия newItemLoading  */
      break;
    case "confirmed":
      return <Component />;
      break;
    case "error":
      return <ErrorMessage />;
      break;
  }
};

const ComicsList = () => {
  const [comicsList, setComicsList] = useState([]);
  const [offset, setOffset] = useState(1);
  const [comicsEnded, setComicsEnded] = useState(false);
  const [newItemLoading, setNewItemLoading] = useState(false);

  const { getAllComics, loading, error, clearError, process, setProcess } =
    useMarvelService();

  useEffect(() => {
    updateComicsList(offset, true);
  }, []);

  const updateComicsList = (offset, initial) => {
    initial ? setNewItemLoading(false) : setNewItemLoading(true);
    getAllComics(offset)
      .then(onComicsListLoaded)
      .then(() => setProcess("confirmed"));
    clearError();
  };

  const onComicsListLoaded = (newComicsList) => {
    let ended = false;
    if (newComicsList.length < 8) {
      ended = true;
    }

    setComicsList((comicsList) => [...comicsList, ...newComicsList]);
    setNewItemLoading(true);
    setOffset((offset) => offset + 9);
    setComicsEnded(ended);
  };

  function renderComicsList(comicsList) {
    const items = comicsList.map((item, i) => {
      let imgStyle = { objectFit: "cover" };
      if (
        item.thumbnail ===
        "http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg"
      ) {
        imgStyle = { objectFit: "unset" };
      }

      return (
        <li className="comics__item" tabIndex={0} key={i}>
          <Link to={`/comics/${item.id}`}>
            <img
              src={item.thumbnail}
              alt={item.name}
              className="comics__item-img"
            />
            <div className="comics__item-name">{item.title}</div>
            <div className="comics__item-price">{item.price}</div>
          </Link>
        </li>
      );
    });
    return <ul className="comics__grid">{items}</ul>;
  }

  return (
    <div className="comics__list">
      {setContent(process, () => renderComicsList(comicsList), newItemLoading)}
      <button
        className="button button__main button__long"
        style={{ display: comicsEnded ? "none" : "block" }}
      >
        <div className="inner" onClick={() => updateComicsList(offset)}>
          load more
        </div>
      </button>
    </div>
  );
};

export default ComicsList;
////

ОШИБКИ СТОРОННИХ БИБЛИОТЕК И ПРОБЛЕМА С ФОКУСОМ:
- если мы подключаем сторонний мод или библиотеку, то некоторые вещи могут работать не совсем так как должны были, в том числе и вызывать некоторые предупрждения

ОСНОВНЫЕ ПРИНЦИПЫ REDUX:
- у нашего первого приложения EmployersList был такой такой подход, как property drill - явление, когда мы при помощи props как-бы "продриливаем" через все компоненты, чтобы передать пропсы и если таких прослоек слишком много, то нам бы приходилось через все эти компоненты передавать пропсы. Отсюда выходит 2 минуса:
	1. нужно создавать весь этот функционал , то есть все методы, которые находятся в главном компоненте, нужно продумать как всё это пробрасывать 
	2.каждый из компонентов таких прослоек может содержать может содержать совершенно ненужные ему свойства(посредник незачем знать и иметь ненужные ему свойства)
- у нашего приложения Marvel App были свои состояния состояния, так как между ними было очень мало зависимостей - такой подход звучит неплохо, но такой подход сложно масштабировать, особенно если начинают появляться зависимости между компонентами(это перерастёт в ситуацию, когда компоненты будут хранить и свою логику внутри себя, и приэтом передавать её туда-сюда - будут стэйты в компонентах + наличие property drill) 
- при создании нового приложения нужно сразу подумать, как его нужно правильно спроектировать, чтобы было потом удобно. Если будет какой-то небольшой проект, то можно взять один з вышеописанных подходов, но как же написать сложное приложение, со сложными зависимостями между компонентами--->на помощь приходит redux
- Redux - это отдельная библиотека
- Redux - это необязательная част реакта, отдельный паттерн, который может использоваться самостоятельно или с другими библиотеками или фрэймворками, это один из вариантов стэйт менеджмента, то есть управления состоянием вашего приложения - это одна из основных задач в любых веб-приложениях, обычных приложениях, которые вы будете создавать . Есть и другие стэйт-мэнэджеры	- например, MobX
- паттерн redux:
	View(наши компоненты, или UI)--->Actions---через dispatch--->Store(Reducer--update-->State)--->View
- хук useReducer был создан после создания Redux и там используются в общем-то все те же сущности и почти та же логика
- 

ОСНОВНЫЕ ПРИНЦИПЫ REDUX.ТЕОРИЯ:
- react-redux - библиотека, которая является прослойкой между реактом и редаксом - создана для того, чтобы вместе их соединять 
- функция reducer всегда должна быть чистой функцией, это значит, что она должна зависеть только от state и action, при этом возвращать один и тот же результат при одинаковых аргументах и не иметь никаких побочных эффектов(в reducer не должно быть никаких случайных чисел, никакой работы с DOM-деревом, никаких console.log-ов и запросов на сервер, то есть ничего того, что могло быпоменять логику работы reducer. Кроме того функция reducer должна соблюдать принципы иммутабельности(тот state, который приходит в не ни в коем случае не должен быть мутирован - если это объект, то создаём её копию и уже работаем с ней)
- напоминание про иммутабельность: в классах мы могли изменять какое-то одно, например, свойство нашего стэйта, просто прописывая только его в this.setState, далее в функцональных компонентах мы пришли к тому, что не можем делать так, как в классах--->необходимо было прописывать ...state и затем изменять то свойство, которое необходимо, чтобы сохранялся принцип иммтубальности--->здесь такая же история
- рассмотрим как работает redux с нативным JS:
////

const initialState = {value: 0};

const reducer = (state = initialState, action) => {
	switch (action.type) {
		case 'INC':
			return {
				...state,
				value: value + 1
			}
		case 'DEC':
			return {
				...state,
				value: value - 1
			}
		case 'RND':
			return {
				...state,
				value: value * action.payload
			}				       // если бы мы вместо action.payload написали Math.floor(Math.random() * 10), то это было бы грубой ошибкой, так мы будем ломать логику 												работы reducer(она должна зависеть только от state и action, при этом возвращать один и тот же результат при одинаковых аргументах и не 											иметь никаких побочных эффектов(в reducer не должно быть никаких случайных чисел)
		default:
			return state
	}
}

const store = createStore(reducer)

const update = () => {
	document.getElementById('counter').textContent = store.getState().value;
}

store.subscribe(update); 			// эта функция вызывается каждый раз, когда изменяется state

const inc = () => {				//передавать объект в dispatch неудобно, когда действий у нас будет много и при этом они будут вызывать одни и те же action---> обычно создают функцию, 								//который возвращает один большой объект + теперь с такой функцией в случае передачи несуществующего action мы будем получать ошибку
	return {
		type: 'INC'
	}
}

const dec = () => ({type: 'DEC'})

const rnd = (value) => ({type: 'RND', payload: value})

document.getElementById('inc').addEventListener('click', () => {
	store.dispatch(inc());
}

document.getElementById('dec').addEventListener('click', () => {
	store.dispatch(dec());
}

document.getElementById('RND').addEventListener('click', () => {
	const value = Math.floor(Math.random() * 10);				//если мы перемещаем логику по созданию случайного числа или запрос ана сервер - это нормально и ошибок мы в таких 																//случаях не допускаем
	store.dispatch(rnd(value));
}

ЧИСТЫЕ ФУНКЦИИ:
- reducer - одна из ключевых функций в redux. Она всегда должны быть чистой 
- 2 главных правила чистых функций мы уже рассмотрели чуть выше:
	1.функция должна возвращать один и тот же результат при одинаковых аргументах
	2.мы не можем использовать побочные эффекты внутри чистых функций( побочные эффекты :
		 *вывод данных в консоль
		 *запросы на сервер - они могут ломать поведение функции, они асинхронны, они могут возвращать разные состояния - ошибку или успех--->у нас появляется стороння зависимость, от 			  которой функция начинает зависеть, она не знает, что вернёт запрос, поэтому мы не можем контролировать и предугадать, какое значение мы получим
		 *работа с DOM-деревом - мало ли чем она может закончиться - элемент может быть не найден, браузер сломался--->не сможеи получить одинаковый результат, как и в предыдущем случае
		 *изменение файлов в нашей файловой системе - мы не можем быть уверены в успехеданной операции и соответственно в результате функции
		 *видоизменение входных данных - это изменение перекликается с прицнипом иммутабельности - любые аргументы, которые приходят к вам в чистую функцию, вы не должны модифицировать, тогда результат всегда будет одинаков и очевиден(state мы никогда не должны напрямую менять - мы должны создвать новую копию стэйта, если хотим с ним работать + нельзя забывать,что некоторые команды также модифицирует какие-то переменные, например, push, которая добавляет массив в какой-то элемент - мы не можем применять её на предыдущем стэйте, потому что мы таким образом будем мутировать предыдущий стэйт--->нужно делать следующее - [...arr, newElement]), ну и action тоже)
- случайное значение можно передать в чистую функцию, но оно должно рассчитываться за пределами reducer, чтобы это значение уже было как-бы сформировано перед отправкой в reducer
- рассмотрим пару примеров из первого правила:
////
const rndSum = a => Math.random() + a;  // эта функция не является чистой - возвращает разные результаты при одном и том же аргументе
const sum = (a, b) => b + a;			 // эта функция - чистая, она предсказуема - теперь и тестировать будет проще и багов будет меньше, да и поиск ошибки будет куда проще, если она 									 //случится. Всё потому что вы понимаете, что результат чётко зависит от входящих параметров
			// это первое правило довольно коварное, его можно непроизвольно нарушить 
let num = 10;	
const sum = a => num += a		//данная функция - не чистая. Данная функция довольно лёгкая, но вот в сложных функциях нужно чёто отслеживать логику её поведения
////
-какие же функции делать у себя в проекте чистыми, ответа конкретного нет - обычно ими делают ключевые сущности, через которые очень часто проходят данные, их нужно часто применять


ОПТИМИЗАЦИЯ ЯЕРЕЗ actionCreators и bindActionCreator:
////
import React from "react";
import ReactDOM from "react-dom/client";
import { createStore, bindActionCreators } from "redux";
import reducer from "./reducer";
import * as actions from "./action";

const store = createStore(reducer);

const { dispatch, subscribe, getState } = store;

const update = () => {
  document.getElementById("counter").textContent = getState().value;
};

// const incDispatch = () => dispatch(inc());   это был первый шаг по оптимизации - мы создали actionCreator--->далее следующий шаг - это создание bindActionCreator
// const decDispatch = () => dispatch(dec());
// const rndDispatch = (value) => dispatch(rnd(value));

const bindActionCreator = (creator, dispatch) => (...args) => {
  //на самом деле эта функция настолько часто повторялась в коде, что она уже есть в самом redux--->мы можем её добавить из библиотеки и у нас больше не будет никакой необходимости создавать её вручную
  //эта функция возвращает функцию, в которой будет что-то происходить
  dispatch(creator(...args));
};

// const incDispatch = bindActionCreators(inc, dispatch);
// const decDispatch = bindActionCreators(dec, dispatch);
// const rndDispatch = bindActionCreators(rnd, dispatch);

//оптимизируем дальше--->на самом деле bindActionCreators позволяет забиндить сразу несколько функций в виде объекта

// const { incDispatch, decDispatch, rndDispatch } = bindActionCreators(
//   //тут возвращается объект
//   {
//     incDispatch: inc,
//     decDispatch: dec,
//     rndDispatch: rnd,
//   },
//   dispatch
// );

//оптимизируем дальше--->если бы мы хотели бы сделать так, чтобы наши actionCreator-ы назывались точно также, то есть inc - inc, то по правилу сокращения объектов можно написать {inc, dec, rnd}, но зачем так делать если у нас есть объект actions, который мы импортировали--->делаем следующее

const { inc, dec, rnd } = bindActionCreators(actions, dispatch); //эта строчка - конечный этап, к которому мы пришли

subscribe(update);

// document.getElementById("inc").addEventListener("click",     1-ый этап оптимизации
//   incDispatch
// );

// document.getElementById("dec").addEventListener("click",
//   decDispatch
// );

// document.getElementById("RND").addEventListener("click", () => {
//   const value = Math.floor(Math.random() * 10);
//   rndDispatch(value);
// });

document.getElementById("inc").addEventListener("click", inc); //конечный этап оптимизации

document.getElementById("dec").addEventListener("click", dec);

document.getElementById("RND").addEventListener("click", () => {
  const value = Math.floor(Math.random() * 10);
  rnd(value);
});
////

ДОБАВЛЯЕМ РЕАКТ В ПРОЕКТ:
////index.js
import React from "react";
import ReactDOM from "react-dom";
import { createStore } from "redux";
import reducer from "./reducer";
import App from "./components/App";
import { Provider } from "react-redux"; //механизм, который работает как контекст, но

const store = createStore(reducer);
const update = () => {
  ReactDOM.render(
    <React.StrictMode>
      <Provider store={store}>
        <App />
        {/* тут мы говорим: всё наше приложение, которое мы поместим в App может пользовать пропсом store. Это механизм, при помощи которого мы берём одну большую сущность store, которая является как-бы отдельным хранилищем для всех наших данных приложений, и связываем его с UI, мы говорим, что на любом дереве вложенности, на любом компоненте мы с вами можем обращаться к стору при помощи dispatch*/}
      </Provider>
    </React.StrictMode>,
    document.getElementById("root")
  );
};
// update();
// subscribe(update); /* компонент <Provider> содержит такой функционал, который содержит все изменения стора, которые происходят в нашем глобальном стэйте и если вдруг что-то изменилось, он будет автоматически сигнализировать об изменениях тем конструкциям, которые мы изучим позже */
////
////App.js
import Counter from "./Counter";

const App = () => {
  return;
  <Counter />;
};
export default App;
////
////Counter.js
const Counter = ({ counter, inc, dec, rnd }) => {
  return (
    <div className="jumbotron">
      <h1>{counter}</h1>
      <button onClick={dec} className="btn btn-primary">
        DEC
      </button>
      <button onClick={inc} className="btn btn-primary">
        INC
      </button>
      <button onClick={rnd} className="btn btn-primary">
        RND
      </button>
    </div>
  );
};

export default Counter;
////

СОЕДИНЯЕМ REACT И REDUX ПРИ ПОМОЩИ CONNECT:
- сейчас мы соединим реакт с редаксом, причём сделаем это при помощи функции connect, как это было в самом начале, когда редакс только появился. В следующем уроке мы перейдём на хуки и будем использовать только их, но знать эту технологию нужно, потому что мы можем встретиться с этим поведением	
- компоненты реакта и редакса можно соединять 2-мя способами:
	1.с помощью connect
	2.через хуки
- теоретически может появиться вопрос, почему мы с вами не можем сделать как в предыдущем уроке, как у нас там был функционал по использованию actionCreator-ов, по вытаскиванию различных команд, то почему бы не сделать это в App.js и не поместить это всё в counter--->теоретически так можно сделать, но это будет совсем не эффективно, когда мы начнём всё это использовать в каждом из компонентов, поэтому и были созданы встроенные методы, которые мы и рассмотрим
- бывают случаи, когда мы не можем использовать хуки: использование классов, поддержка старых проектов, баги с зомби детьми и ещё несколько случаев
- если мы используем connect, то у нас будет немножко больше кода
- если подходить к тестированию приложения, то функция connect будет попроще, потому что состоит из отдельных частей
- хуки будут проще в понимании, но могут быть проблемы с зомби-детьми
- в плане оптимизации работы - connect работает лучше
- когда приложение содержит и манипулирует огромным количеством данных, то функция connect будет работать на самом деле быстрее, но такое бывает редко, поэтому документация рекомендует использовать хуки. Но необходимо знать и то, и то 
- вывод: лучше почти всегда использовать хуки, но в отдельных случаях для оптимизации или для работы с какими-то готовыми классовыми компонентами нам всё равно нужно будет её подключать 
- connect - это компонент высшего порядка(HOC), который оборачивает нужный нам компонент и в качестве пропсов передаёт что-то из нашего стэйта(из нашего стора)
- connect принимает в себя несколько функций(их 4), которые будут настраивать наш компонент:
	1.mapStateToProps -должна быть чистой, синхронной функцией(если будут какие-то сторонние эффекты, то наш компонент может поломаться из-за того, что он не получает нужные пропсы)
////
import { connect } from "react-redux";

const Counter = ({ counter, inc, dec, rnd }) => {
  return (
    <div className="jumbotron">
      <h1>{counter}</h1>
      <button onClick={dec} className="btn btn-primary">
        DEC
      </button>
      <button onClick={inc} className="btn btn-primary">
        INC
      </button>
      <button onClick={rnd} className="btn btn-primary">
        RND
      </button>
    </div>
  );
};

const mapStateToProps = (state) => {
  //эта функция всегда должна возвращать объект с теми свойствами, которые нам нужны из стэйта
  return {
    counter: state.value,
  };
};

export default connect(mapStateToProps)(Counter); // когда функция коннект будет запускаться, она запустит mapStateToProps, эта функция вернёт объект, и этот объект пойдёт на формирование пропсов в нашем компоненте(Counter). Вот таким образом мы можем использовать глобальный стэйт в любой части нашего приложения. Как это происходит: Provider(который оборачивает <App>, в котором в свою очередь находится Counter, который привязан при помощи определённой функции (connect), оповещает connect при об изменении и connect запускается--->запускает mapStateToProps--->перерендер компонента )
////
	2.
////
const mapDispatchToProps = (dispatch) => {
  return {
    inc: () => dispatch(inc()),
    dec: () => dispatch(dec()),
    rnd: () => {
      const value = Math.floor(Math.random() * 10);
      dispatch(rnd(value));
    },
  };
};

export default connect(mapStateToProps, mapDispatchToProps)(Counter);
////--->оптимизируем mapDispatchToProps
const mapDispatchToProps = (dispatch) => {
  const { inc, dec, rnd } = bindActionCreators(actions, dispatch);
  return {
    inc,
    dec,
    rnd: () => {
      const value = Math.floor(Math.random() * 10);
      rnd(value);
    },
  };
};
////оптимизация
// const mapDispatchToProps = (dispatch) => {
//   const { inc, dec, rnd } = bindActionCreators(actions, dispatch);
//   // return {   return можем убрать после того, как мы положили вычисление случ.значения в actio---> самый частый случай, который вы будете встречать - это просто передача в connect аэкшина в качестве второго агумента взамен функции
//   //   inc,
//   //   dec,
//   //   rnd,
//   // };
// };---> теперь скажем об особенности функции connect: если она передаёт вторым аргументом не функцию, а объект в таком случае она все эти манипуляции сделает за вас, то есть она обернёт все рнаши actionCreator-ы, которые приходят в качестве объекта уже в функцию dispatch и сделает это автоматически---> самый частый случай, который вы будете встречать - это просто передача в connect аэкшина в качестве второго агумента взамен функции mapDispatchToProps, но иногда приходится отдельно прописывать эту функцию, так как там могут проходить дополнительные манипуляции и ещё изменяют наши actionCreator-ы, возможно передают дополнительные данные или параметры

export default connect(mapStateToProps, actions)(Counter); 
////
- дальше мы будем применять принцип, который нужно понимать при работе с любым приложением, когда у вас связка react-redux. Мы помним,что говорили, что функция reducer должна быть чистой, поэтому конструкция с вычислением случайного числа мы туда поместить не могли,но при этом мы вручную создали функции actionCreator-ы, на которые это ограничение в общем-то не распространяется(в идеале мы бы хотели, чтобы эти функции были чистыми, но так получается далеко не всегда)--->формирование случайного значения, если это нужно, можем поместить в actionCreator

	3.mergeProps
	4.options - объект 		//встречаются не часто в начале пути, так как они заточены на оптимизацию функции connect
- функции connect всё равно с чем работать, с функциональным компонентом или с классом, она просто берёт компонент и передаёт ему объект пропсов, а как он уже устроен внутри ей всё равно. Если же мы будем использовать хуки, то сможем работать только с функциональным компонентами


СОЕДИНЯЕМ REACT И REDUX ПРИ ПОМОЩИ ХУКОВ:
- селекторы в redux - это функции, которые должны получить кусочек store и давать эту информацию компоненту , они должны быть чистыми и синхронными (функция mapStateToprops по сути является селектором, так как она получает кусочек глобального селектора, то есть стора и передаёт в компонент)
- первый хук - useSelector:
////
const counter = useSelector((state) => state.counter);	//первым аргументом принимает глобальный state
////
- для добавления действий используем второй хук - usedispatch
- единственный способ изменить наш глобальный стэйт - это использовать dispatch с определённым action--->
////
  const dispatch = useDispatch();
  return (
    <div className="jumbotron">
      <h1>{counter}</h1>
      <button onClick={() => dispatch(inc())} className="btn btn-primary">
        DEC
      </button>
      <button onClick={() => dispatch(dec())} className="btn btn-primary">
        INC
      </button>
      <button onClick={() => dispatch(rnd())} className="btn btn-primary">
        RND
      </button>
////
- у хуков есть проблемы с оптимизацией, так как они вызываются и создаются при вызове(при рендеринге нашего компонента)
- разберём чем mapStateToProps отличается от useSelector: 
	*хук может вернуть всё, что угодно, а не только объект, который пойдёт на пропсы(в callback-функции(которая явл. аргументом useSelector) вы можете делать всё, что угодно, только не забывайте, что она должна быть чистой и синхронной. В сам counter мы можем помещать всё, что угодно - это может быть строка, функция или, например, массив, всё, что угодно для решения задачи и это существенный плюс; 
	*с другой стороны в хуке нет аргумента ownProps для передачи собственных пропов для отслеживания; 
	*когда вызывается dispatch, то в таком случае хук ссылочно будет проверять изменение значения и если это значение не изменилось, то и компонент не будет перерендериваться-->это полезно, если в нашем глобальном стэйте не поменялась ссылка на массив или объект, то компонент не будет изменяться; 
	*есть разница в сравнении старого стэйта с новым в useSelector и mapStateToProps при сравнении комбинированного объекта - последний сравнивает только по отдельным полям(мы там создавали объект собственный с названиями свойств, которые сами придумывали, а значения свойств уже брали из стэйта, так вот сравнение будет идти только этих стэйтов(то есть значения свойства) - название свойства затрагиваться не будет)(небольшое отступление - функция mapStateToProps запускается с помощью connect всегда, когда идёт изменение в глобальном стэйте и уже потом смотрит есть ли изменения в пропсе, который существует в компоненте в котором вызван mapStateToProps--->нужен ли перерендер или нет), а вот в useSelector всё не так, там идёт сравнение целого объекта - у него идёт строгое сравнение на значение, возвращаемое из callback-функции и конечно же любое изменение в любом кусочке стэйта приведёт к перерендерингу нашего компонента, потому что каждый раз будет создаваться новый объект в useSelector(ссылки на него всегда новые, а сравнение идёт со старой ссылкой)--->варианты решения данной проблемы:
	1.дублирование useSelector для того, чтобы получить отдельную переменную и потом эти переменные уже где-то использовать внутри нашего компонента(делаем это, чтобы не создвать объект, который всегда будет отличаться от старого по ссылке)
	2.использование сторонней библиотеки Reselect и вытаскивать из неё специальную функцию useSelector - она мемоизирует значение, то есть сравнивать как нужно для того, чтобы мы могли получать 1 большой объект 
	3. добавить функция shallowEqual рядом с useSelector и поместить её рядом с вызовом этого хука(вторым аргументом)
- useDispatch - нужно помнить одно - если мы собираемся действие передавать ниже по иерархии, нужно обязательно использовать useCallback для того, чтобы при перерендеринге нашего компонента у нас не пересоздавался dispatch(чтобы избежать пересоздание дочернего компонента, в который мы помещаем dispatch)
- в хуках есть хук useStore - с помощью него вы можете получать весь store, но это скорее всего никогда не пригодиться
- проблема зомби-детей и так называемых протухших пропсов - это проблема, которая может возникать при использовании хуков - это совсем необязательный материал для начала 
- готовые рецепты от разработчиков:
	1. мы каждый раз повторяем конструкцию dispatch с actionCreator-ом - неужели этот функционал нельзя как-то оптимизировать, применив функционал bindActionCreators - на самом деле с хуками этого делать не стоит, так как повторение кода у нас минимально. На крайний случай можно создавать следующие собственные функции:
////
const boundAddTodo = (text) => dispatch(addTodo(text))
////
import { bindActionCreators } from 'redux'
import { useDispatch } from 'react-redux'
import { useMemo } from 'react'

export function useActions(actions, deps) {
  const dispatch = useDispatch()
  return useMemo(
    () => {
      if (Array.isArray(actions)) {
        return actions.map((a) => bindActionCreators(a, dispatch))
      }
      return bindActionCreators(actions, dispatch)
    },
    deps ? [dispatch, ...deps] : [dispatch]
  )
}
////но такая функция наоборот может запутать и вас, и того, кто посмотрит на ваш код

REDUX DEVTOOLS:
- это специализированный инструмент, который позволяет вам работать с этим хранилищем и позволяет отслеживать то, что происходит 
- для привязки нашего проекта к devtools:
////
const store = createStore(
  reducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);
////

ПРАВИЛА НАЗВАНИЯ ACTION:
- concurrently - библиотека, которая позволяет одновременно запускать несколько команд. Нужно просто её подключить и в package.json прописать следующее:
////
"scripts": {
    "start": "concurrently \"react-scripts start\" \"npx json-server heroes.json --port 3001\""
////
- правила названия экшнов:
	*прописывать тип действия в верхнем регистре 
	*вместо пробела - нижнее подчёркивание 
	*если мы получаем что-то от сервера, то у нас обычно прописывается 3 разных состояния:
		1.ЧТО-ТО_FETCHING
		2.ЧТО-ТО_FETCHED
		3.ЧТО-ТО_FETCHING_ERROR


КОМБИНИРОВАНИЕ REDUCERS  И КРАСИВЫЕ СЕЛЕКТОРЫ:
- сами мы разделить функцию reducers не можем--->на помощь приходит функция combineReducers(reducers)
///тут идёт зависимость функционала друг от друга - filteredHeroes получается на основе heroes, так делать не стоит
const initialState = {
  heroes: [],
  heroesLoadingStatus: "idle",
  filters: [],
  filtersLoadingStatus: "idle",
  activeFilter: "all",
  filteredHeroes: [],
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case "HEROES_FETCHING":
      return {
        ...state,
        heroesLoadingStatus: "loading",
      };
    case "HEROES_FETCHED":
      return {
        ...state,
        heroes: action.payload,
        heroesLoadingStatus: "idle",
        filteredHeroes:
          state.activeFilter === "all"
            ? action.payload
            : action.payload.filter(
                (item) => item.element === state.activeFilter
              ),
        heroesLoadingStatus: "idle",
      };
    case "HEROES_FETCHING_ERROR":
      return {
        ...state,
        heroesLoadingStatus: "error",
      };
    case "FILTERS_FETCHED":
      return {
        ...state,
        filters: action.payload,
        filtersLoadingStatus: "idle",
      };
    case "FILTERS_FETCHING":
      return {
        ...state,
        filtersLoadingStatus: "loading",
      };
    case "FILTERS_FETCHING_ERROR":
      return {
        ...state,
        filtersLoadingStatus: "error",
      };
    case "ACTIVE_FILTER_CHANGED":
      return {
        ...state,
        activeFilter: action.payload,
        filteredHeroes:
          action.payload === "all"
            ? state.heroes
            : state.heroes.filter((item) => item.element === action.payload),
      };
    case "HERO_CREATED":
      let newCreatedHeroList = [...state.heroes, action.payload];
      return {
        ...state,
        heroes: newCreatedHeroList,
        filteredHeroes:
          state.activeFilter === "all"
            ? newCreatedHeroList
            : newCreatedHeroList.filter(
                (item) => item.element === state.activeFilter
              ),
      };
    case "HERO_DELETED":
      const newHeroList = state.heroes.filter(
        (item) => item.id !== action.payload
      );
      return {
        ...state,
        heroes: newHeroList,
        // Фильтруем новые данные по фильтру, который сейчас применяется
        filteredHeroes:
          state.activeFilter === "all"
            ? newHeroList
            : newHeroList.filter((item) => item.element === state.activeFilter),
      };
    default:
      return state;
  }
};

export default reducer;
////
фильтрацией мы можем заниматься на этапе useSelector(на этапе получения каких-то данных со стора(store)) при помощи использования функции внутри useSelector:
////вот так было
const HeroesList = () => {
  const { filteredHeroes, heroesLoadingStatus } = useSelector((state) => state);
  const dispatch = useDispatch();
////
////вот так стало(HeroesList.js)
const HeroesList = () => {
  const filteredHeroes = useSelector((state) => {
    if (state.activeFilter === "all") {
      return state.heroes;
    } else {
      return state.heroes.filter((item) => item.element === state.activeFilter);
    }
  });
  const heroesLoadingStatus = useSelector((state) => state.heroesLoadingStatus);
////
////вот так стало(reducers)
const initialState = {
  heroes: [],
  heroesLoadingStatus: "idle",
  filters: [],
  filtersLoadingStatus: "idle",
  activeFilter: "all",
};
const reducer = (state = initialState, action) => {
  switch (action.type) {
    case "HEROES_FETCHING":
      return {
        ...state,
        heroesLoadingStatus: "loading",
      };
    case "HEROES_FETCHED":
      return {
        ...state,
        heroes: action.payload,
        heroesLoadingStatus: "idle",
        heroesLoadingStatus: "idle",
      };
    case "HEROES_FETCHING_ERROR":
      return {
        ...state,
        heroesLoadingStatus: "error",
      };
    case "FILTERS_FETCHED":
      return {
        ...state,
        filters: action.payload,
        filtersLoadingStatus: "idle",
      };
    case "FILTERS_FETCHING":
      return {
        ...state,
        filtersLoadingStatus: "loading",
      };
    case "FILTERS_FETCHING_ERROR":
      return {
        ...state,
        filtersLoadingStatus: "error",
      };
    case "ACTIVE_FILTER_CHANGED":
      return {
        ...state,
        activeFilter: action.payload,
      };
    case "HERO_CREATED":
      return {
        ...state,
        heroes: [...state.heroes, action.payload],
      };
    case "HERO_DELETED":
      return {
        ...state,
        heroes: state.heroes.filter((item) => item.id !== action.payload),
        // Фильтруем новые данные по фильтру, который сейчас применяется
      };
    default:
      return state;
  }
};

export default reducer;
////
- чем проще reducer, тем проще будет и нам
- теперь у нас в reducer нет каких-либо связей--->разделим этот файл на 2 разных
////heroes.js
const initialState = {
  heroes: [],
  heroesLoadingStatus: "idle",
};
const heroes = (state = initialState, action) => {
  switch (action.type) {
    case "HEROES_FETCHING":
      return {
        ...state,
        heroesLoadingStatus: "loading",
      };
    case "HEROES_FETCHED":
      return {
        ...state,
        heroes: action.payload,
        heroesLoadingStatus: "idle",
      };
    case "HEROES_FETCHING_ERROR":
      return {
        ...state,
        heroesLoadingStatus: "error",
      };
    case "HERO_CREATED":
      return {
        ...state,
        heroes: [...state.heroes, action.payload],
      };
    case "HERO_DELETED":
      return {
        ...state,
        heroes: state.heroes.filter((item) => item.id !== action.payload),
        // Фильтруем новые данные по фильтру, который сейчас применяется
      };
    default:
      return state;
  }
};
export default heroes;
////
////filters.js
const initialState = {
  filters: [],
  filtersLoadingStatus: "idle",
  activeFilter: "all",
};
const filters = (state = initialState, action) => {
  switch (action.type) {
    case "FILTERS_FETCHED":
      return {
        ...state,
        filters: action.payload,
        filtersLoadingStatus: "idle",
      };
    case "FILTERS_FETCHING":
      return {
        ...state,
        filtersLoadingStatus: "loading",
      };
    case "FILTERS_FETCHING_ERROR":
      return {
        ...state,
        filtersLoadingStatus: "error",
      };
    case "ACTIVE_FILTER_CHANGED":
      return {
        ...state,
        activeFilter: action.payload,
      };
    default:
      return state;
  }
};

export default filters;
////
////index.js
import { createStore, combineReducers } from "redux";
import heroes from "../reducers/heroes";
import filters from "../reducers/filters";

const store = createStore(
  combineReducers({
    heroes: heroes,
    filters: filters,
  }) /* теперь обращаться к стэйту нужно вот так - state.heroes.heroes, если нужен список героев, state.filters.filters, если нужны фильтры  */,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);

export default store;
////
////HeroesList.js
const HeroesList = () => {
  const filteredHeroes = useSelector((state) => {
    if (state.filters.activeFilter === "all") {
      return state.heroes.heroes;
    } else {
      return state.heroes.heroes.filter(
        (item) => item.element === state.filters.activeFilter
      );
    }
  });
////такой код не особо приветствуется в мире разработчиков из-за просадки по оптимизации - useSelector вызывается при изменении какого-то глобального стэйта(даже если мы знаем, что значение по факту не изменлось(был триггер к изменению, но к изменению на точно такое же значение)---> здесь лучше использовать продвинутый вариант с мемоизацией - использование библиотеки reselect, а именно одной из функций, которая в ней есть - createSelector
////
import { createSelector } from "reselect";
  const filteredHeroesSelector = createSelector(
    (state) => state.filters.activeFilter,/* первое значение, которое хотим использовать */
    (state) => state.heroes.heroes,/* второе значение, которое хотим использовать */
    (filter,heroes) => {/* то, что мы хотим сделать с этими значениями */
      if (filter === "all") {
        return heroes;
      } else {
        return heroes.filter(
          (item) => item.element === filter
        );
      }
    }
  )
  const filteredHeroes = useSelector(filteredHeroesSelector);
////теперь при изенении на одно и то же значение у нас не будет каждый раз вызываться функция useSelector

STORE ENHANCERS:
- enhancer может расширять любую часть стора
- мы знаем, что в dispatch мы можем отправлять только объекты, у которых должно быть свойство type и по надобности необходимые поля, но иногда так случается, что в dispatch отправляется не строка, а функция или что-то другое--->это вызовет ошибку--->давайте опишем функционал того, что если нам придёт строка, то мы будем вызывать определённое действие:
////
import { createStore, combineReducers } from "redux";
import { compose } from "redux";
import heroes from "../reducers/heroes";
import filters from "../reducers/filters";

const enhancer = (createStore) => (...args) => {
  const store = createStore(...args);

  const oldDisptach = store.dispatch; /* оригинальный dispatch */
  store.dispatch = (action) => {
    if (typeof action === "string") {
      return oldDisptach({
        type: action,
      });
    }
    return oldDisptach(action);
  };
  return store;
};

const store = createStore(
  combineReducers({
    heroes: heroes,
    filters: filters,
  }) /* теперь обращаться к стэйту нужно вот так - state.heroes.heroes, если нужен список героев, state.filters.filters, если нужны фильтры  */,
  compose(			//функция композиции принимает в себя просто функции в качестве аргументов. Тут нужно учитывать порядок функций; если бы у нас был какой-нибудь другой enhancer, то его нужно поставить после нашего enhancer, так как новый enhancer не знал бы что делать со строкой, пришедшей в dispatch и это привело бы к ошибке 
    enhancer,
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
  )
);

export default store;
////
dispatch(heroesFetching()) --поменять на--> dispatch('HEROES_FETCHING')

MIDDLEWARE:
- middleware в отличие от enhancer занимается именно функцией dispatch
////собственный middleware:
const stringMiddleware = () => (dispatch) => (action) => {
  /* внутри первых круглыхскобок можно подставить store или деструктурировать его вот так - { dispatch, getState }, но мы не используем ни dispatch, ни getState, поэтому оставляем сскобочки пустые */
  if (typeof action === "string") {
    return disptach({
      type: action,
    });
  }
  return disptach(action);
};
////
- самый популярный middleware - это redux-thunk
- когда мы подключаем несколько middleware одним за другим, то у нас идёт цепочка вызовов(как при рекурсии,я считаю) - мы последовательно изменяем функции dispatch для того, чтобы получить такую большую мощную функцию:
////
const stringMiddleware = () => (dispatch) => (action) => {
  if (typeof action === "string") {
    return disptach({			//в этот момент запускается второй middleware вместо этого dispatch и передаваться как раз-таки в const stringMiddlewareSecond = () => (dispatch) => (action): этот вот (action) будет значение, которое внутри  нашего dispatch , который как бы должен был вызваться ({type: action}). Именно поэтому в документациях на популярные middleware будет почти везде dispatch будет называться next
      type: action,
    });
  }
  return disptach(action);		////в этот момент запускается второй middleware
}; 

const stringMiddlewareSecond = () => (dispatch) => (action) => {
  if (typeof action === "string") {
    return disptach({
      type: action,
    });
  }
  return disptach(action);
};
---> с учётом изменения названия dispatch на next получаем следующее
////
const stringMiddleware = () => (next) => (action) => {
  /* внутри первых круглыхскобок можно подставить store или деструктурировать его вот так - { dispatch, getState }, но мы не используем ни dispatch, ни getState, поэтому оставляем сскобочки пустые */
  if (typeof action === "string") {
    return next({
      type: action,
    });
  }
  return next(action);
};
////
--->теперь нам нужен механизм, который будет вот так последовательно модифицировать наш dispatch - это встроенная в redux функция - applyMiddleware
const store = createStore(
  combineReducers({
    heroes: heroes,
    filters: filters,
  }),
  compose(
    applyMiddleware(stringMiddleware),
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
  )
);
////
- выводы: middleware - это функции по добавлению функционала и изменению работы dispatch, чаще всего онипозволяют в качестве action принимать не только объекты, но и строки, функции и т.д. Это может быть не только момент оптимизации, но и создание дополнительного функционала. Почти никогда не понадобится создавать их вручную, так как в системе реакта уже есть готовые на любой на вкус

REDUX-THUNK:
- это middleware, который в качестве действий отправлять не объекты, а функции. В свою очередь, если будут диспэтчиться не объекты, а функции, то внутри мы можем делать всё, что угодно, в том числе и асинхроннеы операции(чаще всего ради них всё это и организуют)
//// 
import ReduxThunk from "redux-thunk";

const store = createStore(
  combineReducers({
    heroes: heroes,
    filters: filters,
  }),
  compose(
    applyMiddleware(ReduxThunk, stringMiddleware),
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
  )
////
--->теперь мы можем делать следующее
////
dispatch(heroesFetching()) --поменять на--> dispatch(heroesFetching)
////
- теперь решим одну задачу - надо сделать так, чтобы фильтры переключались с задержкой, то есть вы нажали на кнопочку и только через 1 секунду у нас идёт фильтрация наших героев. Без использования middleware можно было бы обработчик события, который у нас навешен на кнопки, обернуть в setTimeout - но это не красиво и хотелось бы как-то осуществить централизованно--->сделаем изменения в action 
////
export const activeFilterChanged = (filter) => {
  return {
    type: "ACTIVE_FILTER_CHANGED",
    payload: filter,
  };
};
////--->так как мы с вами подключили новый middleware, теперь мы знаем, что можем передать туда не только объекты, но и функцию
export const activeFilterChanged = (filter) => (dispatch) => { //когда мы используем thunk middleware, dispatch приходит сюда автоматически, т.е. нам не нужно никуда её импортировать 
export const activeFilterChanged = (filter) => (dispatch) => {
  return setTimeout(() => {
    dispatch({
      type: "ACTIVE_FILTER_CHANGED",
      payload: filter,
    });
  }, 1000);
};
--->теперь, когда у нас запускается экшнкриэйтор( вот эта часть:export const activeFilterChanged = (filter) ), он будет возвращать функцию, которая в себя принимает dispatch и что-то делает внутри себя. Теперь мы вызываем функцию, которая через 1 секунду будет запускать dispatch. Происходит это из-за того, что middleware автоматически передаёт dispatch в возвращаемую функцию и это открывает нам довольно большой простор для фантазии, ведь в этой функции может происходить всё, что угодно 
- теперь разберём более реальный случай - Чтобы получать список героев, нам сейчас придётся копипастить этот функционал из компонента в компонент:
    dispatch(heroesFetching);
    request("http://localhost:3001/heroes")
      .then((data) => dispatch(heroesFetched(data)))
      .catch(() => dispatch(heroesFetchingError()));
---> почему бы нам тогда не создать одно действие, которое будет включать все эти задачи--->как раз для этого мы можем создать actioncreator в виде функции 
////
export const fetchHeroes = (request) => (dispatch) => {
  dispatch(heroesFetching());
  request("http://localhost:3001/heroes")
    .then((data) => dispatch(heroesFetched(data)))
    .catch(() => dispatch(heroesFetchingError()));
};
////
- одна из главных задач thunk - передаывать функцию, которая потом уже будет что-то делать асинхронно


 Redux Toolkit: configureStore():
-
